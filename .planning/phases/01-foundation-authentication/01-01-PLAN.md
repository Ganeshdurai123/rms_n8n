---
phase: 01-foundation-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - docker/server/Dockerfile
  - docker/client/Dockerfile
  - docker/nginx/nginx.conf
  - docker/nginx/default.conf
  - server/package.json
  - server/tsconfig.json
  - server/src/config/env.ts
  - server/src/config/db.ts
  - server/src/config/redis.ts
  - server/src/middleware/errorHandler.ts
  - server/src/middleware/validate.ts
  - server/src/middleware/pagination.ts
  - server/src/shared/errors.ts
  - server/src/shared/cache.ts
  - server/src/app.ts
  - server/src/server.ts
  - .env.example
  - .env
autonomous: true
requirements:
  - INFRA-01
  - INFRA-02
  - INFRA-03
  - INFRA-04

must_haves:
  truths:
    - "Docker Compose starts all 7 services (mongo, redis, server, client, n8n, n8n_db, nginx) from cold with health checks passing"
    - "Express server connects to MongoDB and Redis on startup without errors"
    - "Nginx proxies /api/* to Express server and /* to client"
    - "All API inputs can be validated through Zod middleware"
    - "List endpoints support pagination (page, limit, total) via middleware"
    - "Redis client is connected and available for caching operations"
  artifacts:
    - path: "docker-compose.yml"
      provides: "All 7 service definitions with health checks"
      contains: "services:"
    - path: "server/src/config/env.ts"
      provides: "Environment variable validation with Zod"
      exports: ["env"]
    - path: "server/src/config/db.ts"
      provides: "MongoDB connection via Mongoose"
      exports: ["connectDB"]
    - path: "server/src/config/redis.ts"
      provides: "Redis client via ioredis"
      exports: ["redis"]
    - path: "server/src/middleware/validate.ts"
      provides: "Generic Zod validation middleware"
      exports: ["validate"]
    - path: "server/src/middleware/pagination.ts"
      provides: "Pagination middleware (page, limit, total)"
      exports: ["paginate"]
    - path: "server/src/middleware/errorHandler.ts"
      provides: "Global error handler"
      exports: ["errorHandler"]
    - path: "server/src/shared/errors.ts"
      provides: "Custom AppError class"
      exports: ["AppError"]
    - path: "server/src/shared/cache.ts"
      provides: "Redis cache helpers (get, set, invalidate)"
      exports: ["cacheGet", "cacheSet", "cacheInvalidate"]
    - path: "server/src/app.ts"
      provides: "Express app with middleware pipeline"
      exports: ["app"]
    - path: "server/src/server.ts"
      provides: "HTTP server entry point"
    - path: "docker/nginx/default.conf"
      provides: "Nginx reverse proxy rules"
      contains: "proxy_pass"
  key_links:
    - from: "docker-compose.yml"
      to: "docker/server/Dockerfile"
      via: "build context"
      pattern: "build:.*docker/server"
    - from: "server/src/server.ts"
      to: "server/src/config/db.ts"
      via: "MongoDB connection on startup"
      pattern: "connectDB"
    - from: "server/src/server.ts"
      to: "server/src/config/redis.ts"
      via: "Redis connection on startup"
      pattern: "redis"
    - from: "server/src/app.ts"
      to: "server/src/middleware/errorHandler.ts"
      via: "Express middleware pipeline"
      pattern: "errorHandler"
    - from: "docker/nginx/default.conf"
      to: "server"
      via: "reverse proxy to Express"
      pattern: "proxy_pass.*server:5000"
---

<objective>
Set up the complete Docker Compose infrastructure with all 7 services, Express server skeleton with TypeScript, MongoDB and Redis connections, Nginx reverse proxy, and core middleware (Zod validation, pagination, error handling, Redis caching utilities).

Purpose: This is the foundation everything else builds on. All subsequent plans depend on Docker Compose running, Express accepting requests, MongoDB storing data, Redis caching, and the middleware pipeline being in place.

Output: A working Docker Compose stack that starts from cold, an Express server with core middleware, and infrastructure utilities ready for feature modules.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md
@.planning/research/PITFALLS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Docker Compose with all 7 services, Dockerfiles, and Nginx reverse proxy</name>
  <files>
    docker-compose.yml
    docker/server/Dockerfile
    docker/client/Dockerfile
    docker/nginx/nginx.conf
    docker/nginx/default.conf
    .env.example
    .env
  </files>
  <action>
Create the Docker Compose file (`docker-compose.yml`) with all 7 services:

1. **mongo** (`mongo:7.0`): Port 27017, volume `mongo_data:/data/db`, healthcheck using `mongosh --eval "db.adminCommand('ping')"` with interval 10s, timeout 5s, retries 5.

2. **redis** (`redis:7.2-alpine`): Port 6379, volume `redis_data:/data`, healthcheck using `redis-cli ping` with interval 10s, timeout 5s, retries 5.

3. **n8n_db** (`postgres:16-alpine`): Port 5432, volume `n8n_db_data:/var/lib/postgresql/data`, env vars `POSTGRES_USER=n8n`, `POSTGRES_PASSWORD=${N8N_DB_PASSWORD}`, `POSTGRES_DB=n8n`, healthcheck using `pg_isready -U n8n` with interval 10s, timeout 5s, retries 5.

4. **n8n** (`n8nio/n8n:latest`): Port 5678, depends_on n8n_db (condition: service_healthy), volume `n8n_data:/home/node/.n8n`, env vars: `DB_TYPE=postgresdb`, `DB_POSTGRESDB_HOST=n8n_db`, `DB_POSTGRESDB_PORT=5432`, `DB_POSTGRESDB_DATABASE=n8n`, `DB_POSTGRESDB_USER=n8n`, `DB_POSTGRESDB_PASSWORD=${N8N_DB_PASSWORD}`, `N8N_BASIC_AUTH_ACTIVE=true`, `N8N_BASIC_AUTH_USER=${N8N_USER}`, `N8N_BASIC_AUTH_PASSWORD=${N8N_PASSWORD}`, `WEBHOOK_URL=http://n8n:5678/`. Healthcheck using `wget --spider -q http://localhost:5678/healthz || exit 1` with interval 30s, timeout 10s, retries 3, start_period 30s.

5. **server** (build from `docker/server/Dockerfile`): Port 5000, depends_on mongo and redis (condition: service_healthy), env_file `.env`, healthcheck using `wget --spider -q http://localhost:5000/api/v1/health || exit 1` with interval 15s, timeout 5s, retries 5, start_period 15s. Volumes: `./server:/app` and `/app/node_modules` (anonymous) for dev hot-reload.

6. **client** (build from `docker/client/Dockerfile`): Port 3000, depends_on server (condition: service_healthy). Volumes: `./client:/app` and `/app/node_modules` for dev hot-reload.

7. **nginx** (`nginx:1.27-alpine`): Ports 80:80, depends_on server and client (condition: service_started), volumes: `./docker/nginx/default.conf:/etc/nginx/conf.d/default.conf:ro`. Restart always.

All services on a shared `rms_network` bridge network.

Named volumes: `mongo_data`, `redis_data`, `n8n_db_data`, `n8n_data`.

**Dockerfiles:**

`docker/server/Dockerfile`: FROM `node:20-alpine`, WORKDIR `/app`, COPY `package*.json`, RUN `npm ci`, COPY `.`, CMD `["npx", "tsx", "watch", "src/server.ts"]` (dev mode with hot-reload via tsx watch).

`docker/client/Dockerfile`: FROM `node:20-alpine`, WORKDIR `/app`, COPY `package*.json`, RUN `npm ci`, COPY `.`, EXPOSE 3000, CMD `["npm", "run", "dev", "--", "--host", "0.0.0.0"]` (Vite dev server exposed to Docker network).

**Nginx config:**

`docker/nginx/default.conf`: Upstream blocks for server (server:5000) and client (client:3000). Server block on port 80:
- `location /api/` -> proxy_pass to server upstream, with standard proxy headers (`Host`, `X-Real-IP`, `X-Forwarded-For`, `X-Forwarded-Proto`)
- `location /socket.io/` -> proxy_pass to server upstream, with WebSocket upgrade headers (`Upgrade $http_upgrade`, `Connection "upgrade"`)
- `location /api/v1/internal/` -> return 403 (block external access to internal endpoints)
- `location /` -> proxy_pass to client upstream

The `/internal/` block rule MUST appear before the generic `/api/` rule in nginx. This prevents external callers from reaching n8n callback endpoints (per PITFALLS.md Pitfall 2).

`docker/nginx/nginx.conf`: Standard nginx.conf with `worker_processes auto`, `events { worker_connections 1024; }`, include of `/etc/nginx/conf.d/*.conf`.

**.env.example and .env:**

Create `.env.example` with all required variables (comments explaining each):
```
# MongoDB
MONGO_URI=mongodb://mongo:27017/rms

# Redis
REDIS_URL=redis://redis:6379

# JWT
JWT_ACCESS_SECRET=change-me-access-secret
JWT_REFRESH_SECRET=change-me-refresh-secret
JWT_ACCESS_EXPIRY=15m
JWT_REFRESH_EXPIRY=7d

# n8n
N8N_DB_PASSWORD=change-me-n8n-db-password
N8N_USER=admin
N8N_PASSWORD=change-me-n8n-password
N8N_WEBHOOK_BASE_URL=http://n8n:5678/webhook
N8N_WEBHOOK_SECRET=change-me-webhook-secret

# Internal API
INTERNAL_API_KEY=change-me-internal-api-key

# Server
PORT=5000
NODE_ENV=development

# Client
CLIENT_URL=http://localhost
VITE_API_URL=http://localhost/api
```

Copy `.env.example` to `.env` with the same development defaults.
  </action>
  <verify>
Run `docker compose config` from the project root to validate the compose file syntax. Verify all 7 services are listed, all health checks are defined, and all volumes are declared. Verify nginx config syntax with `docker compose run --rm nginx nginx -t`. Verify both Dockerfiles exist and have valid FROM statements.
  </verify>
  <done>
docker-compose.yml defines all 7 services (mongo, redis, n8n_db, n8n, server, client, nginx) with health checks, volumes, and network. Nginx config blocks external access to /api/v1/internal/ and proxies WebSocket connections for Socket.IO. .env.example documents every required variable including CLIENT_URL (used for CORS origin with credentialed requests), with separate JWT_ACCESS_SECRET and JWT_REFRESH_SECRET (per PITFALLS.md - never use single secret for both).
  </done>
</task>

<task type="auto">
  <name>Task 2a: Server package init, TypeScript config, environment validation, MongoDB, and Redis</name>
  <files>
    server/package.json
    server/tsconfig.json
    server/src/config/env.ts
    server/src/config/db.ts
    server/src/config/redis.ts
  </files>
  <action>
**Initialize server package:**

`server/package.json` with name `@rms/server`, scripts:
- `"dev": "tsx watch src/server.ts"`
- `"start": "node dist/server.js"`
- `"build": "tsc"`

Install dependencies (npm install from within server/):
- **Runtime:** express, mongoose, ioredis, zod, cors, helmet, compression, morgan, cookie-parser, dotenv, winston
- **Dev:** typescript, tsx, @types/express, @types/cors, @types/compression, @types/morgan, @types/cookie-parser

`server/tsconfig.json`: target ES2022, module NodeNext, moduleResolution NodeNext, outDir dist, rootDir src, strict true, esModuleInterop true, skipLibCheck true, forceConsistentCasingInFileNames true, resolveJsonModule true.

**config/env.ts:**

Use Zod to validate ALL environment variables on startup. Define a `envSchema` with:
- `MONGO_URI`: z.string().url()
- `REDIS_URL`: z.string()
- `JWT_ACCESS_SECRET`: z.string().min(32)
- `JWT_REFRESH_SECRET`: z.string().min(32)
- `JWT_ACCESS_EXPIRY`: z.string().default('15m')
- `JWT_REFRESH_EXPIRY`: z.string().default('7d')
- `PORT`: z.coerce.number().default(5000)
- `NODE_ENV`: z.enum(['development', 'production', 'test']).default('development')
- `CLIENT_URL`: z.string().default('http://localhost')
- `N8N_WEBHOOK_BASE_URL`: z.string().url().optional()
- `N8N_WEBHOOK_SECRET`: z.string().optional()
- `INTERNAL_API_KEY`: z.string().min(32)

Parse and export as `env`. If validation fails, log the errors clearly and exit process (do not silently continue with invalid env).

**config/db.ts:**

Export `connectDB()` async function. Uses `mongoose.connect(env.MONGO_URI)` with connection event listeners for `connected`, `error`, and `disconnected`. Log each event with winston. Set `mongoose.set('strictQuery', true)`.

**config/redis.ts:**

Create and export an ioredis instance: `new Redis(env.REDIS_URL)`. Add event listeners for `connect`, `error`, `close`. Log each with winston. Export the redis client as default.
  </action>
  <verify>
From the server directory, run `npx tsc --noEmit` to verify TypeScript compiles without errors. Verify that removing MONGO_URI from .env causes a clear Zod validation error on startup (then restore it). Verify `CLIENT_URL` is present in the validated env export.
  </verify>
  <done>
server/package.json exists with all runtime and dev dependencies. TypeScript is configured with strict mode and NodeNext module resolution. Environment variables are validated with Zod on startup including CLIENT_URL (invalid vars cause clear error + exit). MongoDB connection function and Redis client are configured with event logging via winston.
  </done>
</task>

<task type="auto">
  <name>Task 2b: Core middleware, shared utilities, Express app, and HTTP server</name>
  <files>
    server/src/shared/errors.ts
    server/src/shared/cache.ts
    server/src/middleware/errorHandler.ts
    server/src/middleware/validate.ts
    server/src/middleware/pagination.ts
    server/src/app.ts
    server/src/server.ts
  </files>
  <action>
**shared/errors.ts:**

Export `AppError` class extending `Error` with `statusCode: number`, `isOperational: boolean`. Constructor takes `(message, statusCode, isOperational = true)`. Also export `NotFoundError`, `UnauthorizedError`, `ForbiddenError`, `ValidationError` as convenience subclasses.

**shared/cache.ts:**

Export cache helper functions using the redis client:
- `cacheGet<T>(key: string): Promise<T | null>` - gets and JSON.parses, returns null on miss
- `cacheSet(key: string, data: unknown, ttlSeconds?: number): Promise<void>` - JSON.stringifies and SET with optional EX
- `cacheInvalidate(pattern: string): Promise<void>` - uses redis.keys(pattern) then redis.del() for pattern-based invalidation
- Default TTL constants: `CACHE_TTL_LIST = 300` (5 min), `CACHE_TTL_CONFIG = 900` (15 min)

**middleware/errorHandler.ts:**

Global Express error handler `(err, req, res, next)`. If `err` is `AppError`, respond with its statusCode and message. If Zod `ZodError`, respond with 400 and formatted validation errors (path + message for each issue). If Mongoose `ValidationError`, respond with 400. Otherwise, 500 with generic message in production (full error in development). Always log errors with winston. Never leak stack traces in production.

**middleware/validate.ts:**

Generic Zod validation middleware factory: `validate(schema: ZodSchema, source: 'body' | 'query' | 'params' = 'body')`. Returns middleware that parses `req[source]` against the schema. On success, replaces `req[source]` with parsed data (strips unknown fields). On failure, passes ZodError to next() for errorHandler.

**middleware/pagination.ts:**

Pagination middleware: `paginate(defaultLimit = 20, maxLimit = 100)`. Parses `req.query.page` (default 1, min 1) and `req.query.limit` (default 20, max 100) into integers. Attaches `req.pagination = { page, limit, skip }` where `skip = (page - 1) * limit`. Also export a helper `paginatedResponse(data, total, page, limit)` that returns `{ data, pagination: { page, limit, total, pages: Math.ceil(total / limit) } }`.

**app.ts:**

Create and export Express app with middleware in this order:
1. `helmet()` - security headers
2. `cors({ origin: env.CLIENT_URL, credentials: true })` - CORS with credentials for cookies (uses validated CLIENT_URL from env.ts, not process.env with '*' fallback)
3. `compression()` - gzip
4. `express.json({ limit: '10mb' })` - JSON body parsing
5. `express.urlencoded({ extended: true })` - URL-encoded parsing
6. `cookieParser()` - cookie parsing (needed for HttpOnly refresh token cookies)
7. `morgan('dev')` - request logging (dev mode)
8. Health check route: `GET /api/v1/health` returns `{ status: 'ok', timestamp, uptime }`
9. API router placeholder: `app.use('/api/v1', apiRouter)` - apiRouter is an empty Router for now
10. 404 handler: any unmatched route throws `NotFoundError`
11. `errorHandler` - global error handler (must be last)

**IMPORTANT:** Use `env.CLIENT_URL` (from the Zod-validated config) for CORS origin, NOT `process.env.CLIENT_URL || '*'`. The fallback to `'*'` would break credentialed (cookie) requests because browsers reject `Access-Control-Allow-Origin: *` when `credentials: true`.

**server.ts:**

Import dotenv and call `config()` at the top (before any other imports that use env). Import `connectDB`, `redis`, and `app`. Create HTTP server from app. On startup:
1. Validate env (importing env.ts triggers validation)
2. Connect to MongoDB via `connectDB()`
3. Verify Redis connection with `redis.ping()`
4. Start HTTP server on `env.PORT`
5. Log successful startup with winston

Handle graceful shutdown on SIGINT/SIGTERM: close HTTP server, disconnect mongoose, quit redis.
  </action>
  <verify>
Run `docker compose up -d mongo redis` to start database services, wait for health checks, then run `docker compose up server` and verify the health check endpoint returns 200: `curl http://localhost:5000/api/v1/health`. Verify the response includes `{ status: 'ok' }`. Verify CORS header `Access-Control-Allow-Origin` is set to the CLIENT_URL value (not `*`) by sending a preflight request: `curl -H "Origin: http://localhost" -H "Access-Control-Request-Method: POST" -X OPTIONS http://localhost:5000/api/v1/health -v`.
  </verify>
  <done>
Core middleware pipeline is in place: helmet, cors (with validated CLIENT_URL origin for cookie support), compression, JSON parsing, cookie-parser, morgan, Zod validation middleware factory, pagination middleware (page/limit/skip/total), global error handler (handles AppError, ZodError, MongooseValidationError). Redis cache utilities (get/set/invalidate with TTL) are exported and functional. Express server starts, connects to MongoDB and Redis, and responds to GET /api/v1/health. Graceful shutdown handles SIGINT/SIGTERM.
  </done>
</task>

</tasks>

<verification>
1. Run `docker compose up -d` from project root. All 7 services should start and reach healthy status within 60 seconds.
2. Run `docker compose ps` and verify all containers show "healthy" or "running" status.
3. `curl http://localhost/api/v1/health` (through nginx) returns `{ status: 'ok' }`.
4. `curl http://localhost/api/v1/internal/test` returns 403 (nginx blocks internal routes).
5. Server logs show successful MongoDB and Redis connections.
6. An invalid API request body is rejected with a Zod validation error response.
</verification>

<success_criteria>
- Docker Compose starts all 7 services from cold with health checks passing
- Express server connects to MongoDB and Redis and serves health endpoint
- Nginx reverse proxy routes /api/* to Express, blocks /api/v1/internal/* from external access, proxies WebSocket upgrade for /socket.io/
- Zod validation middleware, pagination middleware, and global error handler are functional
- Redis cache utilities are connected and operational
- Environment variables are validated on startup
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-01-SUMMARY.md`
</output>
