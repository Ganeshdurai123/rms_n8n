---
phase: 01-foundation-authentication
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - server/src/modules/auth/auth.model.ts
  - server/src/modules/auth/auth.schema.ts
  - server/src/modules/auth/auth.service.ts
  - server/src/modules/auth/auth.controller.ts
  - server/src/modules/auth/auth.routes.ts
  - server/src/modules/auth/refreshToken.model.ts
  - server/src/config/passport.ts
  - server/src/middleware/authenticate.ts
  - server/src/shared/types.ts
  - server/src/app.ts
  - server/package.json
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-03
  - AUTH-04
  - AUTH-05

must_haves:
  truths:
    - "User can register with email and password and receives a JWT access token and refresh token"
    - "User can log in with valid credentials and receives JWT access token (15min) + refresh token (7d) in HttpOnly cookie"
    - "User can refresh an expired access token by sending the HttpOnly refresh token cookie without re-logging in"
    - "User session persists across browser refresh because refresh token is in HttpOnly cookie (not localStorage)"
    - "User can log out and the refresh token is invalidated server-side (cannot be reused)"
    - "Using a previously-rotated refresh token invalidates the entire token family (reuse detection)"
  artifacts:
    - path: "server/src/modules/auth/auth.model.ts"
      provides: "User Mongoose model with email, password hash, role, isActive"
      contains: "model.*User"
    - path: "server/src/modules/auth/refreshToken.model.ts"
      provides: "RefreshToken Mongoose model with tokenFamily, hashed token, userId, isRevoked, expiresAt"
      contains: "model.*RefreshToken"
    - path: "server/src/modules/auth/auth.service.ts"
      provides: "Auth business logic: register, login, refresh, logout"
      exports: ["register", "login", "refreshToken", "logout"]
    - path: "server/src/modules/auth/auth.controller.ts"
      provides: "Thin controller calling auth service"
      exports: ["register", "login", "refresh", "logout", "me"]
    - path: "server/src/modules/auth/auth.routes.ts"
      provides: "Auth route definitions"
      exports: ["authRouter"]
    - path: "server/src/modules/auth/auth.schema.ts"
      provides: "Zod schemas for auth endpoints"
      exports: ["registerSchema", "loginSchema"]
    - path: "server/src/config/passport.ts"
      provides: "Passport JWT strategy configuration"
      contains: "JwtStrategy"
    - path: "server/src/middleware/authenticate.ts"
      provides: "Authentication middleware using Passport JWT"
      exports: ["authenticate"]
    - path: "server/src/shared/types.ts"
      provides: "Shared TypeScript types and interfaces"
      contains: "Role"
  key_links:
    - from: "server/src/modules/auth/auth.routes.ts"
      to: "server/src/modules/auth/auth.controller.ts"
      via: "route handler registration"
      pattern: "router\\.(post|get).*controller"
    - from: "server/src/modules/auth/auth.controller.ts"
      to: "server/src/modules/auth/auth.service.ts"
      via: "service function calls"
      pattern: "authService\\."
    - from: "server/src/modules/auth/auth.service.ts"
      to: "server/src/modules/auth/auth.model.ts"
      via: "User model queries"
      pattern: "User\\.(findOne|create)"
    - from: "server/src/modules/auth/auth.service.ts"
      to: "server/src/modules/auth/refreshToken.model.ts"
      via: "RefreshToken model queries"
      pattern: "RefreshToken\\.(findOne|create|updateMany)"
    - from: "server/src/config/passport.ts"
      to: "server/src/modules/auth/auth.model.ts"
      via: "User lookup in JWT strategy"
      pattern: "User\\.findById"
    - from: "server/src/app.ts"
      to: "server/src/modules/auth/auth.routes.ts"
      via: "route mounting"
      pattern: "app\\.use.*auth"
---

<objective>
Implement the complete authentication system: user registration, login with JWT (access 15min + refresh 7d), refresh token rotation with HttpOnly cookies and token family reuse detection, logout with server-side invalidation, and Passport.js JWT strategy.

Purpose: Authentication is the absolute dependency for every other module. Every API endpoint beyond health checks requires a verified user identity. Getting refresh token security right here (HttpOnly cookies, family tracking, reuse detection) prevents a costly retrofit later that would invalidate all sessions.

Output: Working auth module with 5 endpoints (register, login, refresh, logout, me), User and RefreshToken models, Passport JWT strategy, and authenticate middleware.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md
@.planning/research/PITFALLS.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: User model, RefreshToken model, Passport JWT strategy, and authentication middleware</name>
  <files>
    server/src/modules/auth/auth.model.ts
    server/src/modules/auth/refreshToken.model.ts
    server/src/config/passport.ts
    server/src/middleware/authenticate.ts
    server/src/shared/types.ts
    server/package.json
  </files>
  <action>
**Install auth dependencies:**

```bash
cd server && npm install passport passport-jwt passport-local jsonwebtoken bcryptjs cookie-parser nanoid
npm install -D @types/passport @types/passport-jwt @types/passport-local @types/jsonwebtoken @types/bcryptjs
```

**shared/types.ts:**

Define core types:
```typescript
export type Role = 'admin' | 'manager' | 'team_member' | 'client';

export interface IUser {
  _id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: Role;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

// Extend Express Request to include user
declare global {
  namespace Express {
    interface User extends IUser {}
  }
}
```

**auth.model.ts (User model):**

Mongoose schema with fields:
- `email`: String, required, unique, lowercase, trim, validate with regex for email format
- `password`: String, required, minlength 8, select: false (never returned in queries by default)
- `firstName`: String, required, trim
- `lastName`: String, required, trim
- `role`: String, enum ['admin', 'manager', 'team_member', 'client'], default 'team_member'
- `isActive`: Boolean, default true
- Timestamps: true (adds createdAt, updatedAt)

Pre-save hook: hash password with bcryptjs (12 rounds) only if password is modified. Use `bcryptjs` (pure JS) NOT `bcrypt` (native addon) per STACK.md.

Instance method: `comparePassword(candidatePassword: string): Promise<boolean>` using bcryptjs.compare.

Index on `{ email: 1 }` unique.

**refreshToken.model.ts:**

Mongoose schema with fields:
- `token`: String, required (store bcryptjs hash of the actual token, NOT the raw token)
- `userId`: ObjectId, ref 'User', required, index
- `tokenFamily`: String, required, index (UUID created at login, used for reuse detection)
- `isRevoked`: Boolean, default false
- `expiresAt`: Date, required
- `createdAt`: Date, default Date.now

Index on `{ userId: 1, tokenFamily: 1 }`.
TTL index on `{ expiresAt: 1 }` with `expireAfterSeconds: 0` so MongoDB auto-deletes expired tokens.

**config/passport.ts:**

Configure Passport JWT strategy:
- Extract JWT from `ExtractJwt.fromAuthHeaderAsBearerToken()`
- Secret: `env.JWT_ACCESS_SECRET`
- On verify: find user by `jwtPayload.sub` (the user ID). If user exists and `isActive === true`, pass user to done callback. If not found or inactive, pass false.
- Initialize passport on the Express app (update app.ts to call `passport.initialize()`).

**middleware/authenticate.ts:**

Export `authenticate` middleware that calls `passport.authenticate('jwt', { session: false })`. This is a thin wrapper. If authentication fails, respond with 401 `{ error: 'Authentication required' }`. Do NOT use Passport's default 401 text (it says "Unauthorized" with no JSON body).

Customize the error response by using a callback in passport.authenticate:
```typescript
export const authenticate = (req: Request, res: Response, next: NextFunction) => {
  passport.authenticate('jwt', { session: false }, (err: Error, user: IUser) => {
    if (err) return next(err);
    if (!user) return next(new UnauthorizedError('Authentication required'));
    req.user = user;
    next();
  })(req, res, next);
};
```
  </action>
  <verify>
Run `npx tsc --noEmit` from the server directory to verify TypeScript compiles. Verify the User model creates properly by writing a quick script that imports User and calls `User.schema.obj` to check fields. Verify bcryptjs is properly installed with `node -e "require('bcryptjs')"`.
  </verify>
  <done>
User model exists with email (unique), password (hashed with bcryptjs, select:false), firstName, lastName, role (4 enum values), isActive. RefreshToken model exists with hashed token, userId, tokenFamily (UUID for reuse detection), isRevoked, expiresAt (TTL auto-delete). Passport JWT strategy extracts Bearer token and validates against User model. authenticate middleware returns JSON 401 on failure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Auth routes, service, controller (register, login, refresh, logout, me)</name>
  <files>
    server/src/modules/auth/auth.schema.ts
    server/src/modules/auth/auth.service.ts
    server/src/modules/auth/auth.controller.ts
    server/src/modules/auth/auth.routes.ts
    server/src/app.ts
  </files>
  <action>
**auth.schema.ts (Zod validation schemas):**

```typescript
export const registerSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8).max(128),
  firstName: z.string().min(1).max(50).trim(),
  lastName: z.string().min(1).max(50).trim(),
});

export const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
});
```

**auth.service.ts:**

All business logic lives here. Controller never touches models directly.

`register(data: RegisterInput): Promise<{ user, accessToken, refreshToken }>`:
1. Check if email already exists -> throw `AppError('Email already registered', 409)`
2. Create User document with role 'team_member' (default for self-registration)
3. Generate token pair (helper function below)
4. Return user (without password) + tokens

`login(email: string, password: string): Promise<{ user, accessToken, refreshToken }>`:
1. Find user by email with `.select('+password')` (password excluded by default)
2. If not found or !isActive -> throw `UnauthorizedError('Invalid credentials')` (same message whether email wrong or password wrong to prevent enumeration)
3. Compare password with bcryptjs
4. If mismatch -> throw `UnauthorizedError('Invalid credentials')`
5. Generate token pair
6. Return user (without password) + tokens

`refreshAccessToken(oldRefreshToken: string): Promise<{ accessToken, refreshToken }>`:
1. Verify the refresh token JWT using `JWT_REFRESH_SECRET` -> extract payload (sub=userId, family=tokenFamily, jti=tokenId)
2. Find the RefreshToken document matching `userId + tokenFamily + isRevoked: false`
3. Compare the incoming token against the stored hash with bcryptjs
4. **REUSE DETECTION:** If no matching non-revoked token found for this family, it means a previously-rotated token is being replayed. Revoke ALL tokens in that family: `RefreshToken.updateMany({ tokenFamily }, { isRevoked: true })`. Throw `UnauthorizedError('Token reuse detected - please log in again')`.
5. If valid: revoke the current token (mark `isRevoked: true`), generate a NEW refresh token in the SAME family, return new access + refresh tokens.

`logout(refreshToken: string): Promise<void>`:
1. Verify the refresh token JWT using `JWT_REFRESH_SECRET` -> extract payload (sub=userId, family=tokenFamily). Identity comes from the token itself, not from authenticate middleware -- this allows users with expired access tokens to log out.
2. Revoke ALL tokens in that family: `RefreshToken.updateMany({ tokenFamily }, { isRevoked: true })`
3. (Do not throw if token is already revoked or JWT verification fails â€” logout should be idempotent)

**Token generation helper (private in auth.service.ts):**

`generateTokenPair(userId: string, role: Role, existingFamily?: string)`:
1. Create a new tokenFamily UUID if not provided (new family on login, reuse family on refresh)
2. Generate access token: `jwt.sign({ sub: userId, role }, JWT_ACCESS_SECRET, { expiresIn: JWT_ACCESS_EXPIRY })`
3. Generate refresh token: `jwt.sign({ sub: userId, family: tokenFamily, jti: nanoid() }, JWT_REFRESH_SECRET, { expiresIn: JWT_REFRESH_EXPIRY })`
4. Hash the refresh token with bcryptjs (10 rounds) and store in RefreshToken collection with userId, tokenFamily, hashed token, expiresAt (calculated from JWT_REFRESH_EXPIRY)
5. Return `{ accessToken, refreshToken, tokenFamily }`

Note: `nanoid` is installed with the other auth dependencies in Task 1.

**auth.controller.ts (thin controller):**

`register`: Call `authService.register(req.body)`. Set refresh token as HttpOnly cookie. Return 201 with `{ user, accessToken }`.

`login`: Call `authService.login(req.body.email, req.body.password)`. Set refresh token as HttpOnly cookie. Return 200 with `{ user, accessToken }`.

`refresh`: Extract refresh token from `req.cookies.refreshToken`. If not present, throw 401. Call `authService.refreshAccessToken(token)`. Set new refresh token as HttpOnly cookie. Return 200 with `{ accessToken }`.

`logout`: Extract refresh token from `req.cookies.refreshToken`. If not present, return 200 (already logged out -- idempotent). Call `authService.logout(token)` (identity is derived from the refresh token JWT payload, not from req.user -- this way users with expired access tokens can still log out). Clear the cookie. Return 200 with `{ message: 'Logged out' }`.

`me`: Return 200 with `{ user: req.user }` (already populated by authenticate middleware).

**Cookie settings for refresh token:**
```typescript
const REFRESH_COOKIE_OPTIONS = {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'strict' as const,
  path: '/api/v1/auth',  // only sent to auth endpoints
  maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days in ms
};
```

Set cookie: `res.cookie('refreshToken', token, REFRESH_COOKIE_OPTIONS)`
Clear cookie: `res.clearCookie('refreshToken', REFRESH_COOKIE_OPTIONS)`

**auth.routes.ts:**

```typescript
const router = Router();
router.post('/register', validate(registerSchema), authController.register);
router.post('/login', validate(loginSchema), authController.login);
router.post('/refresh', authController.refresh);  // No auth required - uses cookie
router.post('/logout', authController.logout);  // No auth required - uses refresh token cookie for identity (so users with expired access tokens can still log out)
router.get('/me', authenticate, authController.me);
export { router as authRouter };
```

**Update app.ts:**

1. Import and initialize Passport: `app.use(passport.initialize())`
2. Mount auth routes: `app.use('/api/v1/auth', authRouter)`
  </action>
  <verify>
Start the server and test the full auth flow with curl:

1. Register: `curl -X POST http://localhost:5000/api/v1/auth/register -H "Content-Type: application/json" -d '{"email":"test@test.com","password":"password123","firstName":"Test","lastName":"User"}' -c cookies.txt` -> expect 201 with user object and accessToken, and a Set-Cookie header for refreshToken.

2. Login: `curl -X POST http://localhost:5000/api/v1/auth/login -H "Content-Type: application/json" -d '{"email":"test@test.com","password":"password123"}' -c cookies.txt` -> expect 200 with user and accessToken.

3. Me: `curl http://localhost:5000/api/v1/auth/me -H "Authorization: Bearer <accessToken>"` -> expect 200 with user.

4. Refresh: `curl -X POST http://localhost:5000/api/v1/auth/refresh -b cookies.txt -c cookies.txt` -> expect 200 with new accessToken and new refresh cookie.

5. Logout: `curl -X POST http://localhost:5000/api/v1/auth/logout -b cookies.txt` -> expect 200 (no Authorization header needed -- identity derived from refresh token cookie).

6. Verify revoked token: Use the old refresh cookie to try refresh again -> expect 401 "Token reuse detected".

7. Unauthenticated access: `curl http://localhost:5000/api/v1/auth/me` (no token) -> expect 401.
  </verify>
  <done>
All 5 auth endpoints work: POST /register (creates user, returns JWT + HttpOnly refresh cookie), POST /login (validates credentials, returns JWT + cookie), POST /refresh (rotates refresh token from HttpOnly cookie, reuse detection invalidates entire token family), POST /logout (does NOT require authenticate middleware -- identity derived from refresh token cookie so users with expired access tokens can still log out; revokes all tokens in family, clears cookie), GET /me (returns authenticated user). Refresh tokens stored server-side as bcrypt hashes with token family tracking. Access tokens are 15min, refresh tokens are 7d. HttpOnly + Secure + SameSite=Strict cookies prevent XSS token theft.
  </done>
</task>

</tasks>

<verification>
1. Register a new user -> receive accessToken in body and refreshToken in HttpOnly cookie
2. Login with the registered user -> same token pattern
3. Access GET /me with the access token -> returns user object
4. Wait for access token to approach expiry (or use a very short expiry for testing), then POST /refresh with the cookie -> receive new access token and new cookie
5. Use the OLD refresh cookie (from step 2) to try another refresh -> should get 401 "Token reuse detected" and ALL tokens in that family should be revoked (reuse detection per PITFALLS.md Pitfall 5)
6. POST /logout with refresh token cookie (no Authorization header needed) -> server revokes all tokens in family, clears cookie
7. After logout, POST /refresh with the old cookie -> should get 401
8. POST /register with invalid data (missing fields, short password) -> 400 with Zod validation errors
9. POST /login with wrong password -> 401 "Invalid credentials" (same message for wrong email or wrong password to prevent enumeration)
</verification>

<success_criteria>
- User can register with email/password and receives JWT access token + HttpOnly refresh token cookie
- User can login and receives the same token pattern
- Refresh token rotation works: old token revoked, new token issued in same family
- Token reuse detection: replaying a rotated-out token revokes the entire token family
- Logout invalidates refresh tokens server-side (identity via refresh token cookie, no Bearer token required -- users with expired access tokens can still log out)
- Sessions persist across browser refresh via HttpOnly cookies (not localStorage)
- Protected endpoints reject unauthenticated requests with 401 JSON response
- Passwords are hashed with bcryptjs, refresh tokens stored as hashes in MongoDB
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-02-SUMMARY.md`
</output>
