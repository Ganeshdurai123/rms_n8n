---
phase: 01-foundation-authentication
plan: 03
type: execute
wave: 3
depends_on:
  - 01-02
files_modified:
  - server/src/middleware/authorize.ts
  - server/src/modules/user/user.schema.ts
  - server/src/modules/user/user.service.ts
  - server/src/modules/user/user.controller.ts
  - server/src/modules/user/user.routes.ts
  - server/src/modules/user/programMember.model.ts
  - server/src/app.ts
autonomous: true
requirements:
  - AUTH-06
  - USER-01
  - USER-02
  - USER-03

must_haves:
  truths:
    - "System enforces RBAC with 4 roles: admin, manager, team_member, client"
    - "Admin can create new users and assign any of the 4 roles"
    - "Admin can view a paginated list of all users"
    - "Admin can edit user details (name, email, role) and deactivate user accounts"
    - "Admin can assign users to programs with specific roles via ProgramMember model"
    - "Non-admin users are rejected with 403 when trying to access user management endpoints"
    - "Deactivated users cannot log in or access any protected endpoint"
  artifacts:
    - path: "server/src/middleware/authorize.ts"
      provides: "RBAC authorization middleware"
      exports: ["authorize"]
    - path: "server/src/modules/user/user.schema.ts"
      provides: "Zod schemas for user management endpoints"
      exports: ["createUserSchema", "updateUserSchema", "assignProgramSchema"]
    - path: "server/src/modules/user/user.service.ts"
      provides: "User management business logic"
      exports: ["createUser", "getUsers", "getUserById", "updateUser", "deactivateUser", "assignToProgram", "removeFromProgram"]
    - path: "server/src/modules/user/user.controller.ts"
      provides: "User management controller"
      exports: ["createUser", "getUsers", "getUserById", "updateUser", "deactivateUser", "assignToProgram", "removeFromProgram"]
    - path: "server/src/modules/user/user.routes.ts"
      provides: "User management route definitions"
      exports: ["userRouter"]
    - path: "server/src/modules/user/programMember.model.ts"
      provides: "ProgramMember Mongoose model for user-program association"
      contains: "model.*ProgramMember"
  key_links:
    - from: "server/src/modules/user/user.routes.ts"
      to: "server/src/middleware/authorize.ts"
      via: "RBAC middleware on admin routes"
      pattern: "authorize.*admin"
    - from: "server/src/modules/user/user.routes.ts"
      to: "server/src/middleware/authenticate.ts"
      via: "JWT authentication on all routes"
      pattern: "authenticate"
    - from: "server/src/modules/user/user.service.ts"
      to: "server/src/modules/auth/auth.model.ts"
      via: "User model queries for CRUD"
      pattern: "User\\.(find|create|findByIdAndUpdate)"
    - from: "server/src/modules/user/user.service.ts"
      to: "server/src/modules/user/programMember.model.ts"
      via: "Program membership operations"
      pattern: "ProgramMember\\.(find|create|deleteOne)"
    - from: "server/src/app.ts"
      to: "server/src/modules/user/user.routes.ts"
      via: "route mounting"
      pattern: "app\\.use.*users"
---

<objective>
Implement RBAC authorization middleware and the complete user management module: admin can create users with roles, list/view/edit/deactivate users, and assign users to programs via a ProgramMember model. All user management endpoints are admin-only, enforced by the centralized authorize middleware.

Purpose: RBAC is the gate for every protected endpoint in the system. Building centralized authorization middleware here prevents scattered inline role checks (PITFALLS.md Pitfall 4). User management enables the admin to onboard team members and clients. The ProgramMember model establishes the user-program association pattern used in every subsequent phase.

Output: Centralized authorize middleware, full user CRUD (admin-only), ProgramMember model, and program assignment endpoints.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
@.planning/phases/01-foundation-authentication/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: RBAC authorization middleware and ProgramMember model</name>
  <files>
    server/src/middleware/authorize.ts
    server/src/modules/user/programMember.model.ts
  </files>
  <action>
**middleware/authorize.ts:**

Create a centralized RBAC middleware factory. This is a CRITICAL architectural piece per PITFALLS.md Pitfall 4 -- all permission checks MUST go through this middleware, never inline `if (role === 'admin')` checks in controllers.

```typescript
import { Request, Response, NextFunction } from 'express';
import { Role } from '../shared/types';
import { ForbiddenError } from '../shared/errors';

/**
 * Role-based authorization middleware.
 * Usage: authorize('admin', 'manager') â€” allows only admin and manager roles.
 * Must be used AFTER authenticate middleware (req.user must exist).
 */
export function authorize(...allowedRoles: Role[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return next(new ForbiddenError('Authentication required before authorization'));
    }
    if (!allowedRoles.includes(req.user.role as Role)) {
      return next(new ForbiddenError('Insufficient permissions'));
    }
    next();
  };
}
```

This is intentionally simple for Phase 1. Program-level authorization (`authorizeProgram`) will be added in Phase 2 when programs exist. The pattern is established: centralized middleware, never inline checks.

**programMember.model.ts:**

ProgramMember Mongoose schema -- the bridge between users and programs. Created now to support USER-03 (admin assigns users to programs). The `programId` will reference a Program model that doesn't exist yet, but the ObjectId reference is fine -- MongoDB doesn't enforce foreign key constraints.

Fields:
- `userId`: ObjectId, ref 'User', required
- `programId`: ObjectId, required (ref 'Program' -- model created in Phase 2)
- `role`: String, enum ['manager', 'team_member', 'client'], required (program-level role, separate from global role. Admin is not a program role -- admins have implicit access to all programs.)
- `addedBy`: ObjectId, ref 'User', required (audit: who assigned this membership)
- `isActive`: Boolean, default true
- Timestamps: true

Indexes:
- `{ userId: 1, programId: 1 }` unique compound (a user can only have one role per program)
- `{ programId: 1 }` for listing members of a program
- `{ userId: 1 }` for listing a user's program memberships

**Important design decision:** ProgramMember is a separate collection, not embedded in User or Program. Per ARCHITECTURE.md Pattern 3, this allows a user to be a manager in Program A but a team_member in Program B. The compound unique index prevents duplicate memberships. Admin role users bypass program membership checks entirely (handled in authorize middleware in Phase 2).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles. Write a quick test: import authorize middleware, create a mock request with `req.user = { role: 'team_member' }`, call `authorize('admin')(req, res, next)` and verify that `next` is called with a ForbiddenError. Then with `req.user = { role: 'admin' }`, verify `next` is called without error. Verify ProgramMember model has the correct compound unique index.
  </verify>
  <done>
authorize middleware is a centralized factory function that checks user role against allowed roles. No inline role checks anywhere. ProgramMember model exists with userId + programId compound unique index, program-level role field (manager/team_member/client), and audit trail (addedBy, timestamps). Pattern is established for all future authorization in the system.
  </done>
</task>

<task type="auto">
  <name>Task 2: User management CRUD endpoints (admin-only) with program assignment</name>
  <files>
    server/src/modules/user/user.schema.ts
    server/src/modules/user/user.service.ts
    server/src/modules/user/user.controller.ts
    server/src/modules/user/user.routes.ts
    server/src/app.ts
  </files>
  <action>
**user.schema.ts (Zod validation schemas):**

```typescript
export const createUserSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8).max(128),
  firstName: z.string().min(1).max(50).trim(),
  lastName: z.string().min(1).max(50).trim(),
  role: z.enum(['admin', 'manager', 'team_member', 'client']),
});

export const updateUserSchema = z.object({
  email: z.string().email().optional(),
  firstName: z.string().min(1).max(50).trim().optional(),
  lastName: z.string().min(1).max(50).trim().optional(),
  role: z.enum(['admin', 'manager', 'team_member', 'client']).optional(),
  isActive: z.boolean().optional(),
});

export const assignProgramSchema = z.object({
  userId: z.string().regex(/^[0-9a-fA-F]{24}$/, 'Invalid user ID'),
  programId: z.string().regex(/^[0-9a-fA-F]{24}$/, 'Invalid program ID'),
  role: z.enum(['manager', 'team_member', 'client']),
});

export const listUsersQuerySchema = z.object({
  page: z.coerce.number().int().min(1).default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
  role: z.enum(['admin', 'manager', 'team_member', 'client']).optional(),
  isActive: z.preprocess(val => val === 'true' ? true : val === 'false' ? false : val, z.boolean().optional()),
  search: z.string().max(100).optional(),
});
```

**user.service.ts:**

`createUser(data: CreateUserInput, createdBy: string): Promise<IUser>`:
1. Check if email already exists -> throw `AppError('Email already registered', 409)`
2. Create User document with provided role (admin explicitly assigns role, unlike self-registration which defaults to team_member)
3. Return user (without password)

`getUsers(query: ListUsersQuery): Promise<{ users, total }>`:
1. Build filter object from query params (role, isActive, search)
2. If `search` is provided, match against `firstName`, `lastName`, or `email` using case-insensitive regex: `{ $or: [{ firstName: { $regex: search, $options: 'i' } }, ...] }`
3. Query with `.select('-password')`, `.skip((page-1)*limit)`, `.limit(limit)`, `.sort({ createdAt: -1 })`
4. Count total with same filter
5. Return `{ users, total }`

`getUserById(userId: string): Promise<IUser>`:
1. Find user by ID, exclude password
2. If not found -> throw `NotFoundError('User not found')`
3. Also fetch user's program memberships: `ProgramMember.find({ userId }).populate('programId', 'name')`
4. Return user with memberships attached

`updateUser(userId: string, data: UpdateUserInput): Promise<IUser>`:
1. If email is being changed, check uniqueness
2. `User.findByIdAndUpdate(userId, data, { new: true, runValidators: true }).select('-password')`
3. If not found -> throw `NotFoundError('User not found')`
4. Return updated user

`deactivateUser(userId: string): Promise<IUser>`:
1. Set `isActive: false` on the user
2. Revoke ALL refresh tokens for this user: `RefreshToken.updateMany({ userId }, { isRevoked: true })`
3. This ensures the deactivated user is immediately logged out everywhere
4. Return updated user

`assignToProgram(data: AssignProgramInput, assignedBy: string): Promise<ProgramMember>`:
1. Verify the user exists and is active -> throw `NotFoundError` if not
2. Create ProgramMember document `{ userId, programId, role, addedBy: assignedBy }`
3. If duplicate (compound unique index violation) -> throw `AppError('User already assigned to this program', 409)`
4. Return the membership

`removeFromProgram(userId: string, programId: string): Promise<void>`:
1. Delete ProgramMember document matching userId + programId
2. If not found -> throw `NotFoundError('Membership not found')`

**user.controller.ts (thin controller):**

Each method: extract params/body, call service, return response with correct status code.
- `createUser`: 201 with created user
- `getUsers`: 200 with `paginatedResponse(users, total, page, limit)` (use the pagination helper from Plan 01)
- `getUserById`: 200 with user + memberships
- `updateUser`: 200 with updated user
- `deactivateUser`: 200 with deactivated user
- `assignToProgram`: 201 with membership
- `removeFromProgram`: 204 no content

**user.routes.ts:**

ALL routes require `authenticate` then `authorize('admin')`. Admin-only.

```typescript
const router = Router();

// All user management routes are admin-only
router.use(authenticate);
router.use(authorize('admin'));

router.post('/', validate(createUserSchema), userController.createUser);
router.get('/', validate(listUsersQuerySchema, 'query'), paginate(), userController.getUsers);
router.get('/:userId', userController.getUserById);
router.patch('/:userId', validate(updateUserSchema), userController.updateUser);
router.delete('/:userId', userController.deactivateUser);  // Soft delete (deactivate)

// Program assignment
router.post('/program-assignments', validate(assignProgramSchema), userController.assignToProgram);
router.delete('/program-assignments/:userId/:programId', userController.removeFromProgram);

export { router as userRouter };
```

Note: DELETE /:userId is a soft delete (deactivate), NOT a hard delete. Users are never removed from the database -- they are deactivated. This preserves audit trail integrity.

**Update app.ts:**

Mount user routes: `app.use('/api/v1/users', userRouter)`

Ensure route order is: auth routes first (no auth required for register/login), then user routes (auth + admin required).

**Seed admin user:**

Add a startup function in `server.ts` or a separate `server/src/config/seed.ts` that runs on first boot:
1. Check if any admin user exists: `User.findOne({ role: 'admin' })`
2. If not, create a default admin: `email: 'admin@rms.local', password: 'Admin123!@#', firstName: 'System', lastName: 'Admin', role: 'admin'`
3. Log the credentials with winston at WARN level so the user sees them on first boot
4. This ensures there is always at least one admin to bootstrap the system
  </action>
  <verify>
Start the server and test with curl:

1. Login as admin (seeded): `curl -X POST http://localhost:5000/api/v1/auth/login -H "Content-Type: application/json" -d '{"email":"admin@rms.local","password":"Admin123!@#"}' -c cookies.txt` -> extract accessToken.

2. Create a user: `curl -X POST http://localhost:5000/api/v1/users -H "Authorization: Bearer <adminToken>" -H "Content-Type: application/json" -d '{"email":"user@test.com","password":"password123","firstName":"New","lastName":"User","role":"team_member"}'` -> expect 201.

3. List users: `curl http://localhost:5000/api/v1/users -H "Authorization: Bearer <adminToken>"` -> expect 200 with paginated response containing both admin and new user.

4. Get user by ID: `curl http://localhost:5000/api/v1/users/<userId> -H "Authorization: Bearer <adminToken>"` -> expect 200.

5. Update user: `curl -X PATCH http://localhost:5000/api/v1/users/<userId> -H "Authorization: Bearer <adminToken>" -H "Content-Type: application/json" -d '{"role":"manager"}'` -> expect 200.

6. Deactivate user: `curl -X DELETE http://localhost:5000/api/v1/users/<userId> -H "Authorization: Bearer <adminToken>"` -> expect 200, user's isActive becomes false.

7. Verify deactivated user cannot login: `curl -X POST http://localhost:5000/api/v1/auth/login -H "Content-Type: application/json" -d '{"email":"user@test.com","password":"password123"}'` -> expect 401.

8. Non-admin access: Login as the team_member user (before deactivation), try `curl http://localhost:5000/api/v1/users -H "Authorization: Bearer <userToken>"` -> expect 403 "Insufficient permissions".

9. Assign user to program: `curl -X POST http://localhost:5000/api/v1/users/program-assignments -H "Authorization: Bearer <adminToken>" -H "Content-Type: application/json" -d '{"userId":"<id>","programId":"<anyObjectId>","role":"team_member"}'` -> expect 201 (programId doesn't need to exist in MongoDB yet).
  </verify>
  <done>
Admin can create users with any of the 4 roles (admin/manager/team_member/client). Admin can view paginated user list with filtering by role, active status, and search. Admin can edit user details and deactivate accounts (soft delete preserving audit trail). Deactivating a user revokes all their refresh tokens for immediate session termination. Admin can assign users to programs with program-level roles via ProgramMember model. Non-admin users get 403 on all user management endpoints. A seed admin user is created on first boot to bootstrap the system.
  </done>
</task>

</tasks>

<verification>
1. Login as seed admin -> create a team_member user -> create a manager user -> create a client user
2. List users -> all 4 users appear with correct roles, paginated
3. Login as team_member -> try GET /users -> 403 Forbidden
4. Login as manager -> try GET /users -> 403 Forbidden
5. As admin, update team_member to manager -> verify role changed
6. As admin, deactivate a user -> verify isActive=false, verify user cannot log in anymore
7. As admin, assign a user to a program (any ObjectId) -> verify ProgramMember created
8. As admin, try to assign same user to same program again -> 409 duplicate
9. As admin, remove user from program -> verify ProgramMember deleted
10. Full flow: register a new user (self-register), verify role is team_member (default), login, access /me -> works, cannot access /users -> 403
</verification>

<success_criteria>
- authorize middleware enforces role-based access control on all user management routes
- Admin can create users with explicit role assignment (all 4 roles)
- Admin can list users with pagination, search, and filters (role, isActive)
- Admin can edit user accounts and deactivate them (soft delete)
- Deactivated users are immediately logged out (refresh tokens revoked)
- Admin can assign users to programs with program-level roles
- Non-admin users receive 403 on all user management endpoints
- System has a seeded admin user on first boot
- No inline role checks exist in controllers -- all authorization goes through middleware
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-03-SUMMARY.md`
</output>
