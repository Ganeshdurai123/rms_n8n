---
phase: 10-sequential-request-chains
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/modules/chain/chain.model.ts
  - server/src/modules/chain/chain.schema.ts
  - server/src/modules/chain/chain.service.ts
  - server/src/modules/chain/chain.controller.ts
  - server/src/modules/chain/chain.routes.ts
  - server/src/modules/request/request.model.ts
  - server/src/modules/request/request.service.ts
  - server/src/modules/request/request.routes.ts
  - server/src/modules/request/request.schema.ts
  - server/src/modules/request/requestDetail.service.ts
  - server/src/modules/audit/auditLog.model.ts
  - server/src/shared/socketEvents.ts
  - server/src/app.ts
autonomous: true
requirements:
  - CHAIN-01
  - CHAIN-02

must_haves:
  truths:
    - "Admin/manager can create a chain with a name, programId, and ordered list of request IDs"
    - "Admin/manager can list chains for a program and get a single chain with its requests and their statuses"
    - "When a request in a chain is completed, the next request in sequence auto-transitions from draft to submitted"
    - "Auto-transition creates audit log entries and fires socket/webhook events"
    - "Chain status (all steps with sequence, title, status) is returned by the chain GET endpoint"
  artifacts:
    - path: "server/src/modules/chain/chain.model.ts"
      provides: "RequestChain Mongoose model with name, programId, steps array"
      contains: "model RequestChain"
    - path: "server/src/modules/chain/chain.service.ts"
      provides: "Chain CRUD and auto-transition logic"
      exports: ["createChain", "getChainById", "getChainsByProgram", "getChainByRequestId", "handleChainProgression"]
    - path: "server/src/modules/chain/chain.routes.ts"
      provides: "Chain REST routes under /programs/:programId/chains"
      contains: "router"
  key_links:
    - from: "server/src/modules/request/request.service.ts"
      to: "server/src/modules/chain/chain.service.ts"
      via: "handleChainProgression called after status->completed transition"
      pattern: "handleChainProgression"
    - from: "server/src/modules/chain/chain.routes.ts"
      to: "server/src/modules/chain/chain.controller.ts"
      via: "Express route handlers"
      pattern: "chainController"
    - from: "server/src/modules/request/requestDetail.service.ts"
      to: "server/src/modules/chain/chain.service.ts"
      via: "getChainByRequestId for chain context in request detail"
      pattern: "getChainByRequestId"
---

<objective>
Create the RequestChain backend: model, CRUD API, and auto-transition logic that advances chains when requests complete.

Purpose: Enables admin/manager to define ordered sequences of requests within a program and have the system automatically activate the next step when the current one completes -- the core mechanics of sequential request chains.

Output: Chain model, CRUD service/controller/routes, auto-transition wiring in transitionRequest, chain context in request detail API.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@server/src/modules/request/request.model.ts
@server/src/modules/request/request.service.ts
@server/src/modules/request/request.routes.ts
@server/src/modules/request/request.schema.ts
@server/src/modules/request/request.controller.ts
@server/src/modules/request/requestDetail.service.ts
@server/src/modules/request/stateMachine.ts
@server/src/modules/audit/auditLog.model.ts
@server/src/modules/audit/audit.utils.ts
@server/src/shared/socketEvents.ts
@server/src/shared/types.ts
@server/src/app.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: RequestChain model, Zod schemas, and CRUD service/controller/routes</name>
  <files>
    server/src/modules/chain/chain.model.ts
    server/src/modules/chain/chain.schema.ts
    server/src/modules/chain/chain.service.ts
    server/src/modules/chain/chain.controller.ts
    server/src/modules/chain/chain.routes.ts
    server/src/modules/audit/auditLog.model.ts
    server/src/shared/socketEvents.ts
    server/src/app.ts
  </files>
  <action>
    **chain.model.ts**: Create a RequestChain Mongoose model with:
    - `name`: string, required, trimmed, 3-100 chars
    - `programId`: ObjectId ref Program, required, indexed
    - `steps`: array of embedded subdocuments, each with:
      - `requestId`: ObjectId ref Request, required
      - `sequence`: number, required (1-based, determines execution order)
    - `status`: enum ['active', 'completed'], default 'active' (completed when last step completes)
    - `createdBy`: ObjectId ref User, required
    - timestamps: true
    - Compound index: { programId: 1, createdAt: -1 }
    - Suppress auto _id on step subdocuments (requestId serves as identifier, same pattern as fieldDefinitions in program.model.ts)
    - Export IRequestChainDocument interface and IChainStep interface

    **chain.schema.ts**: Create Zod schemas:
    - `createChainSchema`: { name: string 3-100, steps: array of { requestId: objectId string, sequence: number int min(1) }, min 2 steps (a chain needs at least 2 requests) }
    - `chainParamsSchema`: { programId: objectId, chainId: objectId }
    - `listChainsQuerySchema`: standard pagination (page, limit defaults)
    - Export types for each

    **chain.service.ts**: Implement:
    - `createChain(data, userId, programId)`: Validates all requestIds belong to programId and are in draft status. Creates chain document. Sets chainId and chainSequence on each Request document. Auto-submits the first request in the chain (sequence=1) by transitioning it from draft to submitted (reuse request.service transitionRequest or do a direct Request.findByIdAndUpdate + audit). Returns created chain with populated step request titles/statuses.
    - `getChainById(chainId)`: Returns chain with steps populated (requestId -> title, status). Throws NotFoundError if not found.
    - `getChainsByProgram(programId, query)`: Paginated list of chains for a program, each with steps populated (requestId -> title, status).
    - `getChainByRequestId(requestId)`: Finds a chain containing this requestId. Returns chain with populated steps, or null if request is not in any chain. Used by request detail to show chain context.
    - `handleChainProgression(completedRequestId, programId, userId)`: Called when a request transitions to 'completed'. Finds the chain containing this request. If found, determines the next step by sequence. If next step exists, transitions that request from draft to submitted: update status, create audit entry ('request.status_changed'), fire emitToProgram and enqueueWebhookEvent, create notification for the next request's creator. If the completed request was the last step, mark chain.status = 'completed'. Fire-and-forget pattern consistent with existing codebase.

    **chain.controller.ts**: Standard Express controller functions:
    - `create`: POST handler, calls createChain
    - `list`: GET handler, calls getChainsByProgram with pagination
    - `getById`: GET handler, calls getChainById
    - Follow exact patterns from request.controller.ts (try/catch, next(err), paginatedResponse for list)

    **chain.routes.ts**: Express router with mergeParams:
    - All routes require authenticate + authorizeProgram({ roles: ['manager'] }) -- only admin/manager can manage chains
    - POST / -- create chain
    - GET / -- list chains with pagination
    - GET /:chainId -- get single chain
    - Mount before /:requestId routes in request.routes.ts is NOT needed -- chains are a sibling resource under programs

    **auditLog.model.ts**: Add 'chain.created' and 'chain.step_auto_submitted' to AUDIT_ACTIONS array. Add 'chain' to AUDIT_ENTITY_TYPES array.

    **socketEvents.ts**: Add 'chain:step_advanced' to SocketEventName union type and ServerToClientEvents interface (for real-time chain progression updates).

    **app.ts**: Mount chainRouter at `/programs/:programId/chains` on the apiRouter (same level as requestRouter). Import chainRouter from chain.routes.ts. Place it after the existing program routes mount.
  </action>
  <verify>
    Run `cd "D:/Niranjan -n8n/rms_proj/server" && npx tsc --noEmit` -- TypeScript compiles without errors.
    Manually verify: chain.model.ts exports RequestChain model, chain.service.ts exports all 5 functions, chain.routes.ts exports router, app.ts imports and mounts chainRouter.
  </verify>
  <done>
    RequestChain model exists with name/programId/steps/status fields. CRUD API (create, list, get) is mounted at /programs/:programId/chains. Chain service has createChain, getChainById, getChainsByProgram, getChainByRequestId, and handleChainProgression functions. Audit actions include chain.created and chain.step_auto_submitted. Socket events include chain:step_advanced.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire auto-transition into transitionRequest and add chain context to request detail</name>
  <files>
    server/src/modules/request/request.service.ts
    server/src/modules/request/request.model.ts
    server/src/modules/request/request.schema.ts
    server/src/modules/request/requestDetail.service.ts
  </files>
  <action>
    **request.model.ts**: Add two optional fields to IRequestDocument and requestSchema:
    - `chainId`: ObjectId ref 'RequestChain', optional, indexed
    - `chainSequence`: Number, optional (the step's position in the chain, 1-based)
    - Add compound index: { chainId: 1, chainSequence: 1 }

    **request.schema.ts**: Add 'chainId' to the listRequestsQuerySchema as an optional objectId string filter. Add 'chainSequence' to sortBy enum options so chain-based sorting is possible.

    **request.service.ts**: In the `transitionRequest` function, AFTER the successful status update and audit log creation, add chain progression logic:
    - If `targetStatus === 'completed'`, call `handleChainProgression(requestId, request.programId.toString(), userId)` using the fire-and-forget pattern (`.then().catch(() => {})`) consistent with existing socket/webhook patterns in the same function.
    - Import handleChainProgression from chain.service.ts.
    - In `getRequests`, add support for the optional `chainId` filter: if `query.chainId` is provided, add `filter.chainId = query.chainId`.

    **requestDetail.service.ts**: After the 4 parallel queries, add a 5th call to `getChainByRequestId(requestId)` to retrieve chain context. Include the chain data (or null) in the returned object as `chain`. This tells the frontend whether the request is part of a chain and what all the steps are. Use the same Promise.all pattern -- add it as the 5th element: `getChainByRequestId(requestId)` imported from chain.service.ts. The return value becomes `{ request, comments, attachments, auditTrail, chain }`.
  </action>
  <verify>
    Run `cd "D:/Niranjan -n8n/rms_proj/server" && npx tsc --noEmit` -- TypeScript compiles without errors.
    Verify request.model.ts has chainId and chainSequence fields.
    Verify transitionRequest calls handleChainProgression when targetStatus is 'completed'.
    Verify requestDetail.service.ts returns chain in its response object.
  </verify>
  <done>
    Request model has chainId and chainSequence fields. When a request transitions to 'completed', the system checks if it's part of a chain and auto-transitions the next request in sequence from draft to submitted. Request detail API returns chain context (chain name, all steps with sequence/title/status) when the request belongs to a chain.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd server && npx tsc --noEmit` passes
2. Chain model: RequestChain schema has name, programId, steps (requestId + sequence), status, createdBy
3. Chain CRUD: POST/GET/GET:id routes mounted at /programs/:programId/chains
4. Auto-transition: transitionRequest to 'completed' triggers handleChainProgression
5. Request model: chainId and chainSequence fields exist
6. Request detail: returns chain context when request is in a chain
7. Audit: chain.created and chain.step_auto_submitted actions are valid
8. Socket: chain:step_advanced event type exists
</verification>

<success_criteria>
- Admin/manager can create a chain via POST /programs/:programId/chains with name and ordered steps
- Chain creation validates all requests belong to the program and are in draft status
- Chain creation auto-submits the first step (sequence 1) from draft to submitted
- GET /programs/:programId/chains returns paginated list of chains with step statuses
- GET /programs/:programId/chains/:chainId returns full chain with populated step data
- When a chained request reaches 'completed', the next step auto-transitions to 'submitted'
- Request detail API (/requests/:requestId/detail) includes chain context when applicable
- All chain mutations produce audit log entries
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-sequential-request-chains/10-01-SUMMARY.md`
</output>
