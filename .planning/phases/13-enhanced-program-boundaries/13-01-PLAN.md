---
phase: 13-enhanced-program-boundaries
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/modules/program/program.model.ts
  - server/src/modules/program/program.schema.ts
  - server/src/modules/program/program.service.ts
  - server/src/modules/program/program.controller.ts
  - server/src/modules/program/program.routes.ts
  - server/src/modules/request/request.service.ts
autonomous: true
requirements: [BOUND-01, BOUND-02, BOUND-03]

must_haves:
  truths:
    - "Admin/manager can configure per-user active request limits on a program"
    - "Request creation is rejected with a clear error when program-wide maxActiveRequests limit is reached"
    - "Request creation is rejected with a clear error when per-user maxActiveRequestsPerUser limit is reached"
    - "Boundary utilization stats are retrievable via API showing current usage vs configured limits"
  artifacts:
    - path: "server/src/modules/program/program.model.ts"
      provides: "maxActiveRequestsPerUser field in settings subdocument"
      contains: "maxActiveRequestsPerUser"
    - path: "server/src/modules/program/program.schema.ts"
      provides: "Zod validation for maxActiveRequestsPerUser in create and update schemas"
      contains: "maxActiveRequestsPerUser"
    - path: "server/src/modules/request/request.service.ts"
      provides: "Boundary enforcement in createRequest checking both limits"
      contains: "checkBoundaryLimits"
    - path: "server/src/modules/program/program.service.ts"
      provides: "getBoundaryStats function returning usage vs limits"
      contains: "getBoundaryStats"
    - path: "server/src/modules/program/program.controller.ts"
      provides: "getBoundaryStats controller handler"
      contains: "getBoundaryStats"
    - path: "server/src/modules/program/program.routes.ts"
      provides: "GET /:programId/boundary-stats route"
      contains: "boundary-stats"
  key_links:
    - from: "server/src/modules/request/request.service.ts"
      to: "server/src/modules/program/program.service.ts"
      via: "checkBoundaryLimits called from createRequest before Request.create"
      pattern: "checkBoundaryLimits"
    - from: "server/src/modules/program/program.routes.ts"
      to: "server/src/modules/program/program.controller.ts"
      via: "boundary-stats route wired to controller"
      pattern: "boundary-stats.*getBoundaryStats"
---

<objective>
Add per-user active request limits to the Program model, enforce both program-wide and per-user limits on request creation with clear error messages, and expose a boundary utilization stats API endpoint.

Purpose: Programs need granular boundary enforcement so admins can control request volume at both the program level (maxActiveRequests) and the individual user level (maxActiveRequestsPerUser). This prevents any single user from flooding a program with requests and gives admins visibility into boundary utilization.

Output: Updated Program model with maxActiveRequestsPerUser, boundary enforcement in request creation, and GET /api/v1/programs/:programId/boundary-stats endpoint returning usage data.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-programs-dynamic-fields/02-01-SUMMARY.md
@.planning/phases/02-programs-dynamic-fields/02-02-SUMMARY.md
@server/src/modules/program/program.model.ts
@server/src/modules/program/program.schema.ts
@server/src/modules/program/program.service.ts
@server/src/modules/program/program.controller.ts
@server/src/modules/program/program.routes.ts
@server/src/modules/request/request.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add maxActiveRequestsPerUser to Program model and Zod schemas</name>
  <files>
    server/src/modules/program/program.model.ts
    server/src/modules/program/program.schema.ts
  </files>
  <action>
1. In `program.model.ts`:
   - Add `maxActiveRequestsPerUser?: number;` to the `settings` object in `IProgramDocument` interface, right after `maxActiveRequests`
   - Add the Mongoose field in the `settings` subdocument of `programSchema`:
     ```
     maxActiveRequestsPerUser: {
       type: Number,
       default: undefined,
     },
     ```

2. In `program.schema.ts`:
   - In `createProgramSchema`'s `settings` object, add:
     `maxActiveRequestsPerUser: z.number().int().min(1).optional()`
     (min 1, not 0 -- a limit of 0 would block all users, which is nonsensical)
   - In `updateProgramSchema`'s `settings` object, add the same:
     `maxActiveRequestsPerUser: z.number().int().min(1).optional()`
   - Both schemas already have `maxActiveRequests: z.number().int().min(0).optional()` -- keep that as-is (min 0 is fine for program-wide since it means "no active requests allowed")

No new files. Both existing fields (maxActiveRequests, maxActiveRequestsPerUser) remain optional -- undefined means "no limit".
  </action>
  <verify>
Run `npx tsc --noEmit` from the server directory to confirm TypeScript compiles cleanly with the new field.
  </verify>
  <done>
Program model has `maxActiveRequestsPerUser` field in settings. Zod schemas validate it as optional positive integer. TypeScript compiles with no errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enforce boundary limits on request creation and add boundary stats API</name>
  <files>
    server/src/modules/request/request.service.ts
    server/src/modules/program/program.service.ts
    server/src/modules/program/program.controller.ts
    server/src/modules/program/program.routes.ts
  </files>
  <action>
1. In `request.service.ts`, add a `checkBoundaryLimits` function (before `createRequest`):

```typescript
/**
 * Check program boundary limits before allowing request creation.
 * "Active" requests = status NOT in ['draft', 'completed', 'rejected'] -- these are requests consuming capacity.
 * Throws AppError with clear message if any limit is exceeded.
 */
async function checkBoundaryLimits(
  program: IProgramDocument,
  programId: string,
  userId: string,
): Promise<void> {
  const activeStatuses = ['submitted', 'in_review', 'approved'];

  // Check program-wide maxActiveRequests
  if (program.settings?.maxActiveRequests !== undefined && program.settings.maxActiveRequests !== null) {
    const totalActive = await Request.countDocuments({
      programId,
      status: { $in: activeStatuses },
    });
    if (totalActive >= program.settings.maxActiveRequests) {
      throw new AppError(
        `Program has reached its maximum active request limit (${program.settings.maxActiveRequests}). Please wait for existing requests to be completed or rejected before creating new ones.`,
        400,
      );
    }
  }

  // Check per-user maxActiveRequestsPerUser
  if (program.settings?.maxActiveRequestsPerUser !== undefined && program.settings.maxActiveRequestsPerUser !== null) {
    const userActive = await Request.countDocuments({
      programId,
      createdBy: userId,
      status: { $in: activeStatuses },
    });
    if (userActive >= program.settings.maxActiveRequestsPerUser) {
      throw new AppError(
        `You have reached your per-user active request limit (${program.settings.maxActiveRequestsPerUser}) in this program. Please wait for your existing requests to be completed or rejected before creating new ones.`,
        400,
      );
    }
  }
}
```

Then in `createRequest()`, add the boundary check call AFTER `checkProgramTimeframe(data.programId)` and BEFORE `validateFields(...)`:
```typescript
// Enforce boundary limits (program-wide + per-user active request caps)
await checkBoundaryLimits(program, data.programId, userId);
```

2. In `program.service.ts`, add a `getBoundaryStats` function:

```typescript
/**
 * Get boundary utilization statistics for a program.
 * Returns current active request counts vs configured limits, plus per-user breakdown.
 */
export async function getBoundaryStats(programId: string) {
  const program = await getProgramById(programId);

  const activeStatuses = ['submitted', 'in_review', 'approved'];

  // Total active request count
  const totalActiveRequests = await Request.countDocuments({
    programId,
    status: { $in: activeStatuses },
  });

  // Per-user active request counts (aggregate by createdBy)
  const perUserCounts = await Request.aggregate([
    {
      $match: {
        programId: new (await import('mongoose')).default.Types.ObjectId(programId),
        status: { $in: activeStatuses },
      },
    },
    {
      $group: {
        _id: '$createdBy',
        activeCount: { $sum: 1 },
      },
    },
    {
      $lookup: {
        from: 'users',
        localField: '_id',
        foreignField: '_id',
        as: 'user',
        pipeline: [{ $project: { firstName: 1, lastName: 1, email: 1 } }],
      },
    },
    { $unwind: { path: '$user', preserveNullAndEmptyArrays: true } },
    {
      $project: {
        userId: '$_id',
        activeCount: 1,
        name: {
          $cond: {
            if: '$user',
            then: { $concat: ['$user.firstName', ' ', '$user.lastName'] },
            else: 'Unknown User',
          },
        },
        email: { $ifNull: ['$user.email', null] },
      },
    },
    { $sort: { activeCount: -1 } },
  ]);

  return {
    programId,
    programName: program.name,
    limits: {
      maxActiveRequests: program.settings?.maxActiveRequests ?? null,
      maxActiveRequestsPerUser: program.settings?.maxActiveRequestsPerUser ?? null,
    },
    usage: {
      totalActiveRequests,
      perUser: perUserCounts.map((u: any) => ({
        userId: u.userId.toString(),
        name: u.name,
        email: u.email,
        activeCount: u.activeCount,
      })),
    },
  };
}
```

IMPORTANT: Import the Request model at the top of program.service.ts:
```typescript
import { Request as RequestModel } from '../request/request.model.js';
```
Use `RequestModel` (not `Request`) to avoid conflict with Express `Request` type. Update the function to use `RequestModel` instead of `Request` in the queries.

Actually, program.service.ts does NOT import Express Request -- it has no Express types. So importing as `Request` from request.model is safe. But to be defensive and avoid confusion, use:
```typescript
import { Request as RequestDoc } from '../request/request.model.js';
```
Then use `RequestDoc.countDocuments(...)` and `RequestDoc.aggregate(...)`.

For the mongoose import in the aggregate, use the existing `import mongoose from 'mongoose'` that should be available. If not already imported, add it. Check the existing imports first. The program.model.ts imports mongoose so the type is available -- but program.service.ts may not import mongoose directly. If needed, add:
```typescript
import mongoose from 'mongoose';
```
Then use `new mongoose.Types.ObjectId(programId)` in the aggregate match.

3. In `program.controller.ts`, add the `getBoundaryStats` controller:

```typescript
/**
 * GET /api/v1/programs/:programId/boundary-stats
 * Admin or program manager views boundary utilization.
 */
export async function getBoundaryStats(
  req: Request,
  res: Response,
  next: NextFunction,
): Promise<void> {
  try {
    const stats = await programService.getBoundaryStats(
      req.params.programId as string,
    );
    res.status(200).json(stats);
  } catch (err) {
    next(err);
  }
}
```

4. In `program.routes.ts`, add the boundary-stats route BEFORE the `/:programId` GET route (to avoid param misparse):

Actually, since `boundary-stats` includes a hyphen and won't collide with ObjectId pattern, it's fine placed after `/:programId`. But to be safe and consistent with existing patterns (e.g., `/export` placed before `/:requestId`), place it BEFORE the generic `/:programId` route:

```typescript
// GET /api/v1/programs/:programId/boundary-stats -- admin/manager with program manager role
router.get(
  '/:programId/boundary-stats',
  authorize('admin', 'manager'),
  authorizeProgram({ roles: ['manager'] }),
  programController.getBoundaryStats,
);
```

Place this AFTER the existing `GET /:programId` route but BEFORE the `PATCH /:programId` route. Since it has the `/boundary-stats` suffix, Express will match it correctly without conflict.
  </action>
  <verify>
1. Run `npx tsc --noEmit` from the server directory -- TypeScript compiles cleanly.
2. Verify the new route appears by grepping for 'boundary-stats' in program.routes.ts.
3. Verify `checkBoundaryLimits` is called in `createRequest` by grepping for it in request.service.ts.
  </verify>
  <done>
Request creation enforces both maxActiveRequests (program-wide) and maxActiveRequestsPerUser (per-user) limits with clear error messages. GET /api/v1/programs/:programId/boundary-stats returns { limits, usage: { totalActiveRequests, perUser[] } } for admin/manager. TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd server && npx tsc --noEmit` passes
2. Program model has maxActiveRequestsPerUser in settings
3. Zod schemas validate maxActiveRequestsPerUser as optional positive integer
4. createRequest calls checkBoundaryLimits before creating the request document
5. checkBoundaryLimits checks both program-wide and per-user active request counts
6. Error messages clearly state which limit was hit and its value
7. GET /:programId/boundary-stats endpoint is wired and protected by admin/manager + authorizeProgram
8. getBoundaryStats returns programName, limits, and per-user usage breakdown
</verification>

<success_criteria>
- Program model supports maxActiveRequestsPerUser configuration
- Creating a request when program-wide limit is reached returns 400 with descriptive message
- Creating a request when per-user limit is reached returns 400 with descriptive message
- Boundary stats API returns current usage vs configured limits with per-user breakdown
- All existing functionality continues to work (maxActiveRequests was already in model, just not enforced)
</success_criteria>

<output>
After completion, create `.planning/phases/13-enhanced-program-boundaries/13-01-SUMMARY.md`
</output>
