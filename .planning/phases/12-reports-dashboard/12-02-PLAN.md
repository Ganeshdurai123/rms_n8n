---
phase: 12-reports-dashboard
plan: 02
type: execute
wave: 2
depends_on:
  - 12-01
files_modified:
  - client/src/lib/types.ts
  - client/src/pages/ReportsPage.tsx
  - client/src/pages/ReportDetailPage.tsx
  - client/src/App.tsx
  - client/src/components/layout/Sidebar.tsx
autonomous: true
requirements:
  - RPT-01
  - RPT-02
  - RPT-03
  - RPT-04

must_haves:
  truths:
    - "User can navigate to a Reports page from the sidebar"
    - "User can generate summary, program, and overdue reports via buttons"
    - "User sees a list of their generated reports with status indicators"
    - "User can click a completed report to view the full results"
    - "Report detail page renders structured data for each report type"
  artifacts:
    - path: "client/src/pages/ReportsPage.tsx"
      provides: "Reports dashboard with generate buttons and report list"
      min_lines: 80
    - path: "client/src/pages/ReportDetailPage.tsx"
      provides: "Report detail view with type-specific data rendering"
      min_lines: 60
    - path: "client/src/lib/types.ts"
      provides: "ReportJob and report result TypeScript types"
      contains: "ReportJob"
  key_links:
    - from: "client/src/pages/ReportsPage.tsx"
      to: "/api/v1/reports"
      via: "api.post to generate, api.get to list"
      pattern: "api\\.(post|get).*reports"
    - from: "client/src/pages/ReportDetailPage.tsx"
      to: "/api/v1/reports/:reportId"
      via: "api.get to fetch report with result"
      pattern: "api\\.get.*reports/"
    - from: "client/src/App.tsx"
      to: "client/src/pages/ReportsPage.tsx"
      via: "React Router route definition"
      pattern: "Route.*reports.*ReportsPage"
---

<objective>
Build the frontend reports dashboard and detail pages. Users can generate reports (summary, program-level, overdue), see report status in a list view, and view completed report results with type-specific data rendering.

Purpose: Provides the user-facing interface for the async report generation pipeline built in Plan 01, completing the full reports workflow from trigger to visualization.
Output: ReportsPage, ReportDetailPage, updated client types, sidebar navigation, and routing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-reports-dashboard/12-01-SUMMARY.md

@client/src/App.tsx
@client/src/lib/api.ts
@client/src/lib/types.ts
@client/src/components/layout/Sidebar.tsx
@client/src/pages/SheetViewPage.tsx
@client/src/pages/ComplianceReviewPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Client types, Reports page with generate UI and report list</name>
  <files>
    client/src/lib/types.ts
    client/src/pages/ReportsPage.tsx
    client/src/App.tsx
    client/src/components/layout/Sidebar.tsx
  </files>
  <action>
    1. Update `client/src/lib/types.ts` -- add report types at the bottom:
       ```
       // ---------- Report Types ----------
       export type ReportType = 'summary' | 'program' | 'overdue';
       export type ReportStatus = 'pending' | 'processing' | 'completed' | 'failed';

       export interface ReportJob {
         _id: string;
         type: ReportType;
         status: ReportStatus;
         params?: { startDate?: string; endDate?: string; programId?: string };
         result?: SummaryReportResult | ProgramReportResult | OverdueReportResult | null;
         requestedBy: string | { _id: string; firstName: string; lastName: string };
         programId?: string | { _id: string; name: string };
         error?: string;
         completedAt?: string;
         createdAt: string;
         updatedAt: string;
       }

       export interface SummaryReportResult {
         byStatus: Array<{ status: string; count: number }>;
         byProgram: Array<{ programId: string; programName: string; count: number }>;
         byMonth: Array<{ month: string; count: number }>;
       }

       export interface ProgramReportResult {
         statusBreakdown: Array<{ status: string; count: number }>;
         fieldDistributions: Array<{ fieldKey: string; fieldLabel: string; values: Array<{ value: string; count: number }> }>;
         avgLifecycleDays: number | null;
       }

       export interface OverdueReportResult {
         overdueRequests: Array<{
           requestId: string;
           title: string;
           programName: string;
           status: string;
           dueDate: string;
           daysOverdue: number;
           assignedTo: { name: string; email: string } | null;
           createdBy: { name: string; email: string };
         }>;
         totalOverdue: number;
       }
       ```

    2. Create `client/src/pages/ReportsPage.tsx`:
       - Top section: "Reports" heading with description text
       - Generate Reports section: Three cards (using existing Card component pattern from ProgramListPage):
         a. "Summary Report" card: description "Request counts by status, program, and timeframe", a date range picker (two date inputs for startDate/endDate, optional), and "Generate" button
         b. "Program Report" card: description "Field distributions and lifecycle metrics", a program selector dropdown (fetch programs via api.get('/programs')), date range optional, "Generate" button
         c. "Overdue Report" card: description "All requests past their due date", optional program filter dropdown, "Generate" button
       - Each Generate button calls api.post('/reports', { type, params, programId }) and on 202 success shows a toast "Report generation started" (use sonner toast) and refreshes the report list
       - Report List section below: Fetch reports via api.get('/reports', { params: { page, limit } })
         - Table with columns: Type (badge), Status (badge with colors: pending=gray, processing=blue, completed=green, failed=red), Requested (relative time from createdAt), Completed (relative time from completedAt or '-')
         - Status badges: use Badge component with variant='outline' and custom color classes (same pattern as ImportHistoryPage status badges)
         - Type badges: summary=purple, program=blue, overdue=orange (outline variant)
         - Clickable rows: completed reports navigate to /reports/:reportId, pending/processing/failed show no navigation
         - Pagination using SheetPagination component (reused from sheet view, same pattern as ImportHistoryPage)
       - Loading state: use Skeleton components while fetching
       - Empty state: "No reports generated yet" centered message
       - Auto-refresh: useEffect with 10-second interval to re-fetch report list while any report has status='pending' or 'processing' (poll for completion). Clear interval when all reports are complete/failed or component unmounts.
       - Also listen for 'report:completed' socket event via useSocket hook to immediately refresh the list when n8n completes a report.

    3. Update `client/src/App.tsx`:
       - Import ReportsPage only (ReportDetailPage import and route will be added in Task 2)
       - Add route inside the AppLayout/ProtectedRoute block:
         - `<Route path="/reports" element={<ReportsPage />} />`
       - Place before the `<Route path="/" ...>` catch-all redirect

    4. Update `client/src/components/layout/Sidebar.tsx`:
       - Add a "Reports" navigation item with the BarChart3 icon from lucide-react (or FileBarChart)
       - Place it after the existing "Programs" nav item
       - Link to "/reports"
       - Use the same NavLink/active class pattern as existing sidebar items
  </action>
  <verify>
    Run `cd client && npx tsc --noEmit` to confirm no TypeScript errors. Check that ReportsPage.tsx exists and imports the correct types. Verify App.tsx has the /reports route. Verify Sidebar has the Reports nav link.
  </verify>
  <done>
    Report types added to client types. ReportsPage renders three generate cards (summary, program, overdue) with parameters, a paginated report list with status/type badges, auto-refresh polling, and socket event listener. Routes added to App.tsx. Sidebar has Reports nav link.
  </done>
</task>

<task type="auto">
  <name>Task 2: Report detail page with type-specific result rendering</name>
  <files>
    client/src/pages/ReportDetailPage.tsx
    client/src/App.tsx
  </files>
  <action>
    1. Create `client/src/pages/ReportDetailPage.tsx`:

    2. Update `client/src/App.tsx`: Import ReportDetailPage, add route `<Route path="/reports/:reportId" element={<ReportDetailPage />} />` next to the existing /reports route.

    ReportDetailPage details:

    - Uses useParams to get reportId, fetches report via api.get(`/reports/${reportId}`)
    - Loading state: Skeleton layout
    - Error state: "Report not found" with back link
    - Pending/Processing state: Show spinner with "Report is being generated..." message and auto-refresh (poll every 5s or listen for socket event 'report:completed')
    - Failed state: Show error message from report.error with red styling

    - Completed state renders type-specific views:

    a. **Summary Report** (type='summary'):
       - "Request Summary" heading with date range if provided
       - Three sections in a grid:
         1. "By Status" section: Horizontal bar chart using simple div-based bars (no chart library -- use Tailwind width percentages). Each status gets a colored bar with count and label. Colors match STATUS_VARIANT from existing components (draft=gray, submitted=blue, in_review=yellow, approved=green, rejected=red, completed=emerald).
         2. "By Program" section: Same div-based bar chart pattern with program names and counts. Use blue shades.
         3. "By Month" section: Simple list/table with month labels and counts. Format months as "Jan 2026", "Feb 2026" etc.
       - Total request count at the top (sum of byStatus counts)

    b. **Program Report** (type='program'):
       - Program name heading (from report.programId.name if populated)
       - "Status Breakdown" section: Same bar chart pattern as summary
       - "Average Lifecycle" section: Display avgLifecycleDays as a highlighted metric card (e.g., "12.5 days average from creation to completion"). Show "N/A" if null.
       - "Field Value Distributions" section: For each field in fieldDistributions, render a sub-section with fieldLabel heading, then a bar chart of value -> count. Handle empty distributions gracefully.

    c. **Overdue Report** (type='overdue'):
       - "Overdue Requests" heading with totalOverdue count
       - Table with columns: Title, Program, Status (badge), Due Date (formatted), Days Overdue (with red color for emphasis), Assigned To, Created By
       - Sort by daysOverdue descending (already sorted by backend)
       - Each row's title is a link to the request detail page (/programs/{programId}/requests/{requestId}) -- note: programId may need to come from the report data

    - Back button: navigate(-1) or link to /reports
    - Report metadata at top: type badge, generated on (createdAt), completed on (completedAt), requested by name

    Pattern notes:
    - Use existing Card, Badge, Skeleton, Button components
    - relativeTime utility can be duplicated locally (same pattern as other pages)
    - Bar widths calculated as (count / maxCount * 100)% for visual proportion
    - No external chart library needed -- simple Tailwind div bars are sufficient for this MVP
  </action>
  <verify>
    Run `cd client && npx tsc --noEmit` to confirm no TypeScript errors. Verify ReportDetailPage.tsx exists with type-specific rendering sections for summary, program, and overdue reports.
  </verify>
  <done>
    ReportDetailPage renders completed reports with type-specific views: summary (by status/program/month bar charts), program (status breakdown, avg lifecycle metric, field distributions), overdue (table of past-due requests with days overdue). Pending reports show loading state with auto-refresh. Failed reports show error. Back navigation to reports list works.
  </done>
</task>

</tasks>

<verification>
1. `cd client && npx tsc --noEmit` -- zero TypeScript errors
2. ReportsPage renders at /reports with three generate cards and a report list
3. ReportDetailPage renders at /reports/:reportId with type-specific result views
4. Sidebar has Reports nav link with chart icon
5. App.tsx routes are correctly configured
6. Report types in types.ts match backend response shapes
7. Auto-refresh and socket listeners handle async report completion
</verification>

<success_criteria>
- User can navigate to /reports from sidebar
- User can generate summary, program, and overdue reports with optional parameters
- Report list shows all user's reports with status badges and pagination
- Completed reports can be viewed with structured data visualization
- Summary: bar charts by status, program, and month
- Program: status breakdown, average lifecycle metric, field value distributions
- Overdue: table of overdue requests with days overdue
- Pending reports auto-refresh until completion
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/12-reports-dashboard/12-02-SUMMARY.md`
</output>
