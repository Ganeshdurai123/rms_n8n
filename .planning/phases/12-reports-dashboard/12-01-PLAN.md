---
phase: 12-reports-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/modules/report/report.model.ts
  - server/src/modules/report/report.schema.ts
  - server/src/modules/report/report.service.ts
  - server/src/modules/report/report.controller.ts
  - server/src/modules/report/report.routes.ts
  - server/src/modules/internal/internal.controller.ts
  - server/src/modules/internal/internal.routes.ts
  - server/src/modules/webhook/webhook.types.ts
  - server/src/app.ts
  - server/n8n-workflows/report-generation-workflow.json
autonomous: true
requirements:
  - RPT-01
  - RPT-02
  - RPT-03
  - RPT-04

must_haves:
  truths:
    - "User can trigger generation of summary, program, or overdue reports via REST API"
    - "Report job is created as pending and webhook is enqueued for n8n async processing"
    - "n8n can call internal API to run aggregation queries and receive structured report data"
    - "n8n can mark a report as complete by posting results back to internal API"
    - "User can list their generated reports and retrieve completed report results"
  artifacts:
    - path: "server/src/modules/report/report.model.ts"
      provides: "ReportJob Mongoose model with type, status, params, result fields"
      contains: "model ReportJob"
    - path: "server/src/modules/report/report.service.ts"
      provides: "Report generation, aggregation queries, list/get service functions"
      exports: ["createReportJob", "getReports", "getReportById", "generateSummaryReport", "generateProgramReport", "generateOverdueReport"]
    - path: "server/src/modules/report/report.routes.ts"
      provides: "Report REST API endpoints"
      exports: ["reportRouter"]
    - path: "server/n8n-workflows/report-generation-workflow.json"
      provides: "Importable n8n workflow for async report generation"
  key_links:
    - from: "server/src/modules/report/report.controller.ts"
      to: "server/src/modules/webhook/webhook.service.ts"
      via: "enqueueWebhookEvent after creating ReportJob"
      pattern: "enqueueWebhookEvent.*report\\.generated"
    - from: "server/src/modules/internal/internal.controller.ts"
      to: "server/src/modules/report/report.service.ts"
      via: "internal API calls aggregation functions"
      pattern: "generate(Summary|Program|Overdue)Report"
    - from: "server/n8n-workflows/report-generation-workflow.json"
      to: "server/src/modules/internal/internal.routes.ts"
      via: "HTTP Request nodes calling /api/v1/internal/report-data and /report-complete"
      pattern: "internal/report"
---

<objective>
Build the backend report infrastructure: ReportJob model, aggregation services for three report types (summary, program-level, overdue), REST API for report generation/listing/retrieval, internal API endpoints for n8n to execute aggregation and store results, and the n8n workflow template for async report generation.

Purpose: Enables async report generation where the user triggers a report, n8n handles the heavy aggregation work, and results are stored for retrieval without blocking the UI.
Output: Complete backend report module, extended internal API, n8n workflow JSON template.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@server/src/modules/request/request.model.ts
@server/src/modules/audit/auditLog.model.ts
@server/src/modules/program/program.model.ts
@server/src/modules/webhook/webhook.types.ts
@server/src/modules/webhook/webhook.service.ts
@server/src/modules/internal/internal.controller.ts
@server/src/modules/internal/internal.routes.ts
@server/src/app.ts
@server/n8n-workflows/due-date-reminder-workflow.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: ReportJob model, aggregation service, and report REST API</name>
  <files>
    server/src/modules/report/report.model.ts
    server/src/modules/report/report.schema.ts
    server/src/modules/report/report.service.ts
    server/src/modules/report/report.controller.ts
    server/src/modules/report/report.routes.ts
    server/src/modules/webhook/webhook.types.ts
    server/src/app.ts
  </files>
  <action>
    1. Create `server/src/modules/report/report.model.ts`:
       - ReportJob Mongoose model with fields:
         - `type`: enum ['summary', 'program', 'overdue'] (required)
         - `status`: enum ['pending', 'processing', 'completed', 'failed'] (default: 'pending')
         - `params`: Schema.Types.Mixed (stores report-specific parameters like programId, dateRange, etc.)
         - `result`: Schema.Types.Mixed (stores completed report data -- null until n8n writes results)
         - `requestedBy`: ObjectId ref User (required, who triggered the report)
         - `programId`: ObjectId ref Program (optional, required for program-type reports)
         - `error`: String (optional, failure reason)
         - `completedAt`: Date (optional, when n8n finished)
         - timestamps: true
       - Indexes: { requestedBy: 1, createdAt: -1 }, { status: 1 }, { programId: 1, type: 1 }
       - Export IReportJobDocument interface and REPORT_TYPES const array

    2. Create `server/src/modules/report/report.schema.ts`:
       - Zod schema `createReportSchema` for POST body:
         - type: z.enum(['summary', 'program', 'overdue'])
         - programId: z.string().optional() (required when type='program' via .refine())
         - params: z.object({ startDate: z.string().datetime().optional(), endDate: z.string().datetime().optional() }).optional()
       - Zod schema `listReportsSchema` for GET query: page, limit (from pagination), type filter, status filter
       - Zod schema `reportIdParamSchema` for :reportId param validation

    3. Create `server/src/modules/report/report.service.ts`:
       - `createReportJob(userId, type, params, programId?)`: Creates ReportJob with status='pending', returns the job. Does NOT run aggregation (n8n does that).
       - `getReports(userId, userRole, query)`: List reports. Admin/manager see all, others see own only. Supports type/status filter, pagination.
       - `getReportById(reportId, userId, userRole)`: Get single report with result. Admin/manager see any, others see own only. Throw NotFoundError/ForbiddenError.
       - `generateSummaryReport(params)`: MongoDB aggregation on Request collection:
         - Group by status -> count per status
         - Group by programId -> count per program (populate program name)
         - Group by month (createdAt) -> count per month for timeframe breakdown
         - Apply date range filter from params.startDate/endDate if provided
         - Return { byStatus: [{status, count}], byProgram: [{programId, programName, count}], byMonth: [{month, count}] }
       - `generateProgramReport(programId, params)`: MongoDB aggregation:
         - Request count by status within this program
         - Field value distributions: for each dropdown/checkbox fieldDefinition, aggregate distinct values with counts from request.fields Map
         - Average lifecycle duration: compute avg time from createdAt to completedAt for completed requests (using $match status=completed + $group with $avg on $subtract)
         - Apply date range filter if provided
         - Return { statusBreakdown, fieldDistributions: [{fieldKey, fieldLabel, values: [{value, count}]}], avgLifecycleDays }
       - `generateOverdueReport(params)`: MongoDB query:
         - Find requests where dueDate < now AND status in ['submitted', 'in_review']
         - Populate createdBy (firstName, lastName, email), assignedTo (firstName, lastName, email), programId (name)
         - Compute daysOverdue for each
         - Sort by daysOverdue descending (most overdue first)
         - Apply programId filter from params if provided
         - Return { overdueRequests: [{requestId, title, programName, status, dueDate, daysOverdue, assignedTo, createdBy}], totalOverdue }
       - `completeReport(reportId, result)`: Update ReportJob status='completed', store result, set completedAt=now
       - `failReport(reportId, error)`: Update ReportJob status='failed', store error message

    4. Create `server/src/modules/report/report.controller.ts`:
       - `generateReport` (POST): Validate body, call createReportJob, then fire-and-forget enqueueWebhookEvent('report.requested', payload with reportId, type, params). Return 202 Accepted with { reportId, status: 'pending', message: 'Report generation started' }.
       - `listReports` (GET): Call getReports with pagination, return paginatedResponse.
       - `getReport` (GET /:reportId): Call getReportById, return report (including result if completed).

    5. Create `server/src/modules/report/report.routes.ts`:
       - Router with authenticate middleware on all routes
       - POST / -> validate(createReportSchema, 'body'), paginate, generateReport
       - GET / -> validate(listReportsSchema, 'query'), paginate, listReports
       - GET /:reportId -> validate(reportIdParamSchema, 'params'), getReport
       - Export reportRouter

    6. Update `server/src/modules/webhook/webhook.types.ts`:
       - Add 'report.requested' to WEBHOOK_EVENT_TYPES array
       - The existing WebhookPayload shape works (eventType, programId, requestId can be reportId, data has report params)

    7. Update `server/src/app.ts`:
       - Import reportRouter from './modules/report/report.routes.js'
       - Mount at: app.use('/api/v1/reports', reportRouter) -- place before the 404 handler
       - Comment: "// 18b. Report routes (authenticated users can generate and view reports)"
  </action>
  <verify>
    Run `cd server && npx tsc --noEmit` to confirm no TypeScript errors. Verify the report module files exist with correct exports. Check that webhook.types.ts includes 'report.requested'.
  </verify>
  <done>
    ReportJob model created with type/status/params/result fields. Three aggregation functions (summary, program, overdue) implemented. REST API at /api/v1/reports with POST (generate), GET (list), GET/:id (detail). Report generation returns 202 and enqueues webhook for n8n. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Internal API endpoints for n8n report execution and n8n workflow template</name>
  <files>
    server/src/modules/internal/internal.controller.ts
    server/src/modules/internal/internal.routes.ts
    server/n8n-workflows/report-generation-workflow.json
  </files>
  <action>
    1. Update `server/src/modules/internal/internal.controller.ts` -- add two new handlers:

       a. `getReportData` handler (GET /internal/report-data):
          - Query params: reportId (required), type ('summary'|'program'|'overdue')
          - Inline validation (internal API is trusted, no Zod middleware -- same pattern as getPendingReminders)
          - Look up ReportJob by reportId, extract type and params
          - Update ReportJob status to 'processing'
          - Call the appropriate generate function from report.service.ts based on type:
            - 'summary' -> generateSummaryReport(params)
            - 'program' -> generateProgramReport(programId, params)
            - 'overdue' -> generateOverdueReport(params)
          - Return aggregation result as JSON
          - Wrap in try/catch, call failReport(reportId, error) on failure and return 500

       b. `completeReportHandler` handler (POST /internal/report-complete):
          - Body: { reportId (required), result (required -- the report data) }
          - Inline validation for required fields
          - Call completeReport(reportId, result) from report.service.ts
          - Fire-and-forget: emit socket event to notify the requesting user their report is ready (use user-targeted socket emission pattern from notification service -- iterate io.sockets.sockets, find socket with matching userId from the ReportJob.requestedBy, emit 'report:completed' event)
          - Return 200 with { success: true }

    2. Update `server/src/modules/internal/internal.routes.ts`:
       - Import getReportData and completeReportHandler from internal.controller.ts
       - Add: internalRouter.get('/report-data', getReportData)
       - Add: internalRouter.post('/report-complete', completeReportHandler)
       - Keep comment style consistent with existing route comments

    3. Create `server/n8n-workflows/report-generation-workflow.json`:
       - Follow the exact same JSON structure as due-date-reminder-workflow.json
       - Workflow name: "Report Generation"
       - Trigger: n8n-nodes-base.webhook (not schedule -- this is triggered by webhook from Express outbox)
         - Webhook path: "report.requested" (matches the outbox eventType routing pattern)
         - Method: POST
         - Response mode: "lastNode" so n8n acknowledges after processing
       - Node 2: "Fetch Report Data" (httpRequest):
         - GET http://server:5000/api/v1/internal/report-data?reportId={{$json.body.data.reportId}}&type={{$json.body.data.type}}
         - Header x-api-key: ={{$env.INTERNAL_API_KEY}}
       - Node 3: "Complete Report" (httpRequest):
         - POST http://server:5000/api/v1/internal/report-complete
         - Header x-api-key: ={{$env.INTERNAL_API_KEY}}, Content-Type: application/json
         - Body: { "reportId": "{{$json.body.data.reportId || $node['Fetch Report Data'].json.reportId}}", "result": the fetched aggregation data }
         - Use specifyBody: "json" with jsonBody referencing the report data from the previous node
       - Connections: Webhook Trigger -> Fetch Report Data -> Complete Report
       - Set active: false (user must configure before enabling -- consistent with other workflows)
       - Settings: executionOrder "v1"
  </action>
  <verify>
    Run `cd server && npx tsc --noEmit` to confirm no TypeScript errors. Verify internal.routes.ts has the two new routes. Verify n8n-workflows/report-generation-workflow.json is valid JSON (use `node -e "JSON.parse(require('fs').readFileSync('server/n8n-workflows/report-generation-workflow.json', 'utf8'))"` to validate).
  </verify>
  <done>
    Internal API has GET /report-data (runs aggregation, returns data to n8n) and POST /report-complete (stores result, notifies user via socket). n8n workflow JSON template follows webhook-trigger -> fetch-data -> complete-report flow. Full async pipeline: user triggers -> outbox -> n8n webhook -> internal API aggregation -> store result -> socket notify user. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `cd server && npx tsc --noEmit` -- zero TypeScript errors
2. ReportJob model exists at server/src/modules/report/report.model.ts with correct schema
3. Three report types implemented: summary (by status/program/month), program (status breakdown + field distributions + avg lifecycle), overdue (past due requests with days overdue)
4. REST API at /api/v1/reports: POST returns 202, GET lists reports, GET/:id returns report with result
5. Internal API: GET /internal/report-data runs aggregation, POST /internal/report-complete stores result
6. Webhook type 'report.requested' added to event catalog
7. n8n workflow JSON is valid and follows webhook->fetch->complete pattern
</verification>

<success_criteria>
- ReportJob model persists report requests with type, status, params, and result
- POST /api/v1/reports creates a pending report job and enqueues webhook for n8n
- n8n workflow receives webhook, calls internal API to run aggregation, posts result back
- Internal API executes MongoDB aggregations for all three report types
- GET /api/v1/reports lists reports (access-scoped), GET /api/v1/reports/:id returns full result
- All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-reports-dashboard/12-01-SUMMARY.md`
</output>
