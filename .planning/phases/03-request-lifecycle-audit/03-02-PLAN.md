---
phase: 03-request-lifecycle-audit
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - server/src/modules/request/request.service.ts
  - server/src/modules/request/request.controller.ts
  - server/src/modules/request/request.routes.ts
  - server/src/app.ts
autonomous: true
requirements:
  - REQ-01
  - REQ-02
  - REQ-03
  - REQ-04
  - REQ-05
  - REQ-09
  - REQ-10
  - AUDIT-01

must_haves:
  truths:
    - "User can create a request within a program with dynamic fields validated against program field definitions"
    - "User can submit a draft request and the status changes to submitted"
    - "Manager can move request through submitted -> in_review -> approved/rejected -> completed with only valid transitions"
    - "Invalid state transitions are rejected with 400 error"
    - "Manager can assign/reassign a request to a team member"
    - "Every mutation (create, update, status change, assignment) writes an audit log entry"
  artifacts:
    - path: "server/src/modules/request/request.service.ts"
      provides: "Request business logic with CRUD, transitions, assignment, audit logging"
      exports: ["createRequest", "getRequestById", "getRequests", "updateRequest", "transitionRequest", "assignRequest"]
    - path: "server/src/modules/request/request.controller.ts"
      provides: "Thin Express controllers delegating to service"
      exports: ["create", "list", "getById", "update", "transition", "assign"]
    - path: "server/src/modules/request/request.routes.ts"
      provides: "Express routes for request CRUD + transitions + assignment"
      contains: "router"
  key_links:
    - from: "server/src/modules/request/request.service.ts"
      to: "server/src/modules/request/request.model.ts"
      via: "Request.create, Request.find"
      pattern: "Request\\.(create|find|findById)"
    - from: "server/src/modules/request/request.service.ts"
      to: "server/src/modules/audit/audit.utils.ts"
      via: "createAuditEntry calls on every mutation"
      pattern: "createAuditEntry"
    - from: "server/src/modules/request/request.service.ts"
      to: "server/src/modules/request/stateMachine.ts"
      via: "canUserTransition for status validation"
      pattern: "canUserTransition"
    - from: "server/src/modules/request/request.service.ts"
      to: "server/src/modules/program/program.service.ts"
      via: "getProgramById for field validation and checkProgramTimeframe"
      pattern: "getProgramById|checkProgramTimeframe"
    - from: "server/src/app.ts"
      to: "server/src/modules/request/request.routes.ts"
      via: "app.use mount"
      pattern: "app\\.use.*requestRouter"
---

<objective>
Build the core request lifecycle API: CRUD operations, state machine transitions, assignment/reassignment, and audit logging for every mutation. This is the central business logic of the application.

Purpose: This plan delivers the primary request management capability -- users can create requests with dynamic fields, submit them for review, and managers can shepherd requests through the full lifecycle. Every change is audited.

Output: 4 files (service, controller, routes, app.ts update) providing the complete request CRUD + lifecycle API.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-request-lifecycle-audit/03-01-SUMMARY.md

Key references:
@server/src/modules/program/program.service.ts (service pattern: CRUD + caching + error handling)
@server/src/modules/program/program.controller.ts (controller pattern: thin, delegates to service)
@server/src/modules/program/program.routes.ts (route pattern: middleware layering)
@server/src/middleware/authorizeProgram.ts (program-scoped authorization)
@server/src/modules/request/request.model.ts (Request model from Plan 01)
@server/src/modules/request/request.schema.ts (Zod schemas from Plan 01)
@server/src/modules/request/stateMachine.ts (state machine from Plan 01)
@server/src/modules/audit/audit.utils.ts (audit utility from Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Request service with CRUD, state transitions, assignment, and audit logging</name>
  <files>
    server/src/modules/request/request.service.ts
  </files>
  <action>
Create the request service following the established service-layer pattern from program.service.ts. All business logic lives here -- controllers never touch models directly.

**`createRequest(data, userId, userRole)`:**
- Fetch program via `getProgramById(data.programId)` to verify it exists.
- Call `checkProgramTimeframe(data.programId)` to enforce submission boundaries (archived, not started, ended).
- Validate `data.fields` against the program's `fieldDefinitions`:
  - For each fieldDefinition where `required: true`, verify the key exists in data.fields and is not null/undefined/empty.
  - For dropdown fields, verify the value is one of the defined `options`.
  - For number fields, verify the value is a number.
  - For checkbox fields, verify the value is boolean.
  - For date fields, verify the value parses as a valid date.
  - For text fields, verify the value is a string.
  - Reject any field key in data.fields that does not exist in program.fieldDefinitions (no extra fields allowed).
  - Throw `ValidationError` with descriptive message for each violation.
- Create the Request document with `status: 'draft'`, `createdBy: userId`.
- Store fields as a plain object (Mongoose Map will handle serialization).
- Call `createAuditEntry({ action: 'request.created', entityType: 'request', entityId: request._id, requestId: request._id, programId: data.programId, performedBy: userId, after: request.toObject() })`.
- Invalidate request list cache: `cacheInvalidate('requests:list:*')`.
- Return the created request.

**`getRequestById(requestId)`:**
- Cache key: `requests:${requestId}`.
- Populate `createdBy` (firstName, lastName, email), `assignedTo` (firstName, lastName, email), `programId` (name).
- Use `.lean()` for performance.
- Cache with CACHE_TTL_CONFIG.

**`getRequests(query, programId, userId, userRole)`:**
- Build filter: always include `programId`.
- If `query.status`, add to filter.
- If `query.assignedTo`, add to filter.
- If `query.priority`, add to filter.
- If `query.search`, add `$or` on title and description (case-insensitive regex, same pattern as program.service.ts).
- Access scoping: if userRole is 'client', add `createdBy: userId` to filter (clients only see their own requests). If userRole is 'team_member', add filter for `$or: [{ createdBy: userId }, { assignedTo: userId }]` (team members see their own + assigned). Admin and manager see all requests in the program.
- Paginate with skip/limit, sort by createdAt descending.
- Cache with CACHE_TTL_LIST, cache key includes programId + userId for non-admin roles.
- Return `{ requests, total, page, limit }`.

**`updateRequest(requestId, data, userId, userRole)`:**
- Fetch existing request. Verify it exists.
- Verify status is 'draft' (only draft requests can have fields edited -- submitted+ requests are immutable except through transitions).
- If `data.fields` provided, validate against program fieldDefinitions (same validation as create).
- Capture `before` snapshot: `request.toObject()`.
- Apply updates with `findByIdAndUpdate` and `runValidators: true`.
- Call `createAuditEntry({ action: 'request.updated', ..., before, after: updated.toObject() })`.
- If fields were changed, also log `createAuditEntry({ action: 'request.field_edited', ..., metadata: { changedFields: Object.keys(data.fields) } })`.
- Invalidate caches: `requests:${requestId}`, `requests:list:*`.
- Return updated request.

**`transitionRequest(requestId, targetStatus, userId, userRole)`:**
- Fetch existing request.
- Call `canUserTransition(request.status, targetStatus, userRole)`. If false, throw `AppError('Invalid status transition', 400)` with descriptive message including current and target status.
- Additional rule: for `draft->submitted`, only the request creator can submit (verify `request.createdBy.toString() === userId`). For `rejected->submitted`, also only the creator.
- Capture before status.
- Update request status with `findByIdAndUpdate`.
- Call `createAuditEntry({ action: 'request.status_changed', ..., before: { status: beforeStatus }, after: { status: targetStatus }, metadata: { from: beforeStatus, to: targetStatus } })`.
- Invalidate caches.
- Return updated request.

**`assignRequest(requestId, assignedToUserId, performedByUserId)`:**
- Fetch existing request.
- Verify request status is NOT 'draft' or 'completed' (assignment only for active requests).
- Verify the assignee is a member of the request's program (check ProgramMember collection) with role 'team_member' or 'manager'. Admin global role also valid.
- Capture before assignedTo.
- Update `assignedTo` field.
- Call `createAuditEntry({ action: 'request.assigned', ..., before: { assignedTo: beforeAssignee }, after: { assignedTo: assignedToUserId }, metadata: { assignedTo: assignedToUserId } })`.
- Invalidate caches.
- Return updated request.

**Important patterns to follow:**
- Import from established shared modules: `AppError, NotFoundError, ValidationError, ForbiddenError` from `../../shared/errors.js`
- Import cache utilities: `cacheGet, cacheSet, cacheInvalidate, CACHE_TTL_CONFIG, CACHE_TTL_LIST` from `../../shared/cache.js`
- Import `getProgramById, checkProgramTimeframe` from `../program/program.service.js`
- Import `canUserTransition` from `./stateMachine.js`
- Import `createAuditEntry` from `../audit/audit.utils.js`
- Import `ProgramMember` from `../user/programMember.model.js` (for assignment validation)
  </action>
  <verify>
Run `npx tsc --noEmit` from server/. The service file must compile cleanly. Verify all 6 functions are exported. Verify audit logging calls are present in create, update, transition, and assign functions.
  </verify>
  <done>
Request service implements all CRUD + lifecycle operations. Dynamic field validation works against program field definitions. State machine enforces valid transitions with role checks. Every mutation creates an audit entry. Access scoping prevents clients from seeing others' requests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Request controller, routes, and app.ts mount</name>
  <files>
    server/src/modules/request/request.controller.ts
    server/src/modules/request/request.routes.ts
    server/src/app.ts
  </files>
  <action>
Create controller and routes following established patterns, then mount on app.

**Request controller** (`server/src/modules/request/request.controller.ts`):
Thin controllers that delegate to the service layer. Each function: extract input from req, call service, send response.

- `create`: Extract body from req, call `createRequest(req.body, req.user._id, req.user.role)`, respond 201 with `{ data: request }`.
- `list`: Extract query params, call `getRequests(req.query, req.params.programId, req.user._id, req.user.role)`, respond 200 with `paginatedResponse(requests, total, page, limit)`.
- `getById`: Call `getRequestById(req.params.requestId)`, respond 200 with `{ data: request }`.
- `update`: Call `updateRequest(req.params.requestId, req.body, req.user._id, req.user.role)`, respond 200 with `{ data: request }`.
- `transition`: Call `transitionRequest(req.params.requestId, req.body.status, req.user._id, req.user.role)`, respond 200 with `{ data: request }`.
- `assign`: Call `assignRequest(req.params.requestId, req.body.assignedTo, req.user._id)`, respond 200 with `{ data: request }`.

All controllers wrapped in try/catch passing errors to `next()`.

**Request routes** (`server/src/modules/request/request.routes.ts`):
Routes are nested under programs: `/api/v1/programs/:programId/requests/...`

```
const router = Router({ mergeParams: true });

// All routes require authentication
router.use(authenticate);

// All routes require program access
router.use(authorizeProgram());

// POST /programs/:programId/requests -- create request (all program members)
router.post('/', validate(createRequestSchema), create);

// GET /programs/:programId/requests -- list requests (all program members, access-scoped)
router.get('/', validate(listRequestsQuerySchema, 'query'), list);

// GET /programs/:programId/requests/:requestId -- get single request
router.get('/:requestId', validate(requestParamsSchema, 'params'), getById);

// PATCH /programs/:programId/requests/:requestId -- update request fields (draft only)
router.patch('/:requestId', validate(requestParamsSchema, 'params'), validate(updateRequestSchema), update);

// PATCH /programs/:programId/requests/:requestId/transition -- change status
router.patch('/:requestId/transition', validate(requestParamsSchema, 'params'), validate(transitionRequestSchema), transition);

// PATCH /programs/:programId/requests/:requestId/assign -- assign/reassign
router.patch('/:requestId/assign', validate(requestParamsSchema, 'params'), validate(assignRequestSchema), authorizeProgram({ roles: ['manager'] }), assign);
```

Note: The assign route adds `authorizeProgram({ roles: ['manager'] })` -- only program managers (and admins via bypass) can assign. The second authorizeProgram call is fine since the first one already ran via `router.use()` and set `req.programMembership`.

Export `requestRouter`.

**app.ts update:**
- Import `requestRouter` from `./modules/request/request.routes.js`
- Mount: `app.use('/api/v1/programs/:programId/requests', requestRouter)` -- BEFORE the 404 handler.
- The `mergeParams: true` on the router ensures `req.params.programId` is accessible in nested routes.
  </action>
  <verify>
Run `npx tsc --noEmit` from server/. All files compile. Verify app.ts has the requestRouter mount. Verify routes use the three-layer middleware pattern: authenticate -> authorizeProgram -> validate -> controller.
  </verify>
  <done>
Request CRUD API is fully functional at /api/v1/programs/:programId/requests with proper authentication, program-scoped authorization, validation, and controller->service->model flow. Status transitions and assignment endpoints enforce business rules. All routes follow established middleware patterns.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes from server/ with zero errors
2. POST /programs/:programId/requests creates a draft request with validated dynamic fields
3. PATCH /requests/:requestId/transition enforces valid state machine transitions
4. PATCH /requests/:requestId/assign validates assignee is a program member
5. Every mutation (create, update, transition, assign) calls createAuditEntry
6. Access scoping: clients see only their requests, team members see own + assigned
7. app.ts mounts requestRouter at the correct path with mergeParams
</verification>

<success_criteria>
- Request CRUD with dynamic field validation against program field definitions
- State machine transitions enforced with role-based authorization
- Assignment restricted to program managers, assignee validated as program member
- Audit log entry created for every mutation operation
- Access-scoped request listing by user role
- All routes protected by authenticate + authorizeProgram middleware
- Zero TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-request-lifecycle-audit/03-02-SUMMARY.md`
</output>
