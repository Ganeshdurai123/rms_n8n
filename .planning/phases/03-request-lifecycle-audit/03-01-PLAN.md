---
phase: 03-request-lifecycle-audit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/modules/request/request.model.ts
  - server/src/modules/request/comment.model.ts
  - server/src/modules/request/attachment.model.ts
  - server/src/modules/audit/auditLog.model.ts
  - server/src/modules/request/request.schema.ts
  - server/src/modules/audit/audit.schema.ts
  - server/src/modules/request/stateMachine.ts
  - server/src/modules/audit/audit.utils.ts
autonomous: true
requirements:
  - REQ-01
  - REQ-02
  - REQ-05
  - REQ-09
  - AUDIT-01

must_haves:
  truths:
    - "Request model stores dynamic field values keyed to program field definitions"
    - "State machine defines valid transitions and which roles can trigger each transition"
    - "AuditLog model captures who, what, when, before/after for every mutation type"
    - "Comment and Attachment models are linked to requests for activity tracking"
  artifacts:
    - path: "server/src/modules/request/request.model.ts"
      provides: "Request Mongoose model with dynamic fields, status, assignment"
      contains: "model Request"
    - path: "server/src/modules/request/comment.model.ts"
      provides: "Comment Mongoose model linked to request"
      contains: "model Comment"
    - path: "server/src/modules/request/attachment.model.ts"
      provides: "Attachment Mongoose model with file metadata"
      contains: "model Attachment"
    - path: "server/src/modules/audit/auditLog.model.ts"
      provides: "AuditLog Mongoose model for mutation tracking"
      contains: "model AuditLog"
    - path: "server/src/modules/request/request.schema.ts"
      provides: "Zod schemas for request CRUD and transitions"
      exports: ["createRequestSchema", "updateRequestSchema", "transitionRequestSchema"]
    - path: "server/src/modules/request/stateMachine.ts"
      provides: "State machine transition map and validator"
      exports: ["VALID_TRANSITIONS", "canTransition"]
    - path: "server/src/modules/audit/audit.utils.ts"
      provides: "Reusable audit log creation utility"
      exports: ["createAuditEntry"]
  key_links:
    - from: "server/src/modules/request/request.model.ts"
      to: "Program.fieldDefinitions"
      via: "programId reference and dynamic fields map"
      pattern: "ref.*Program"
    - from: "server/src/modules/audit/audit.utils.ts"
      to: "server/src/modules/audit/auditLog.model.ts"
      via: "AuditLog.create call"
      pattern: "AuditLog\\.create"
---

<objective>
Create the data foundation for Phase 3: Mongoose models for Request, Comment, Attachment, and AuditLog, plus Zod validation schemas, the request state machine transition map, and a reusable audit logging utility.

Purpose: All subsequent plans (request CRUD, comments, attachments, audit views) depend on these models and schemas existing first. The state machine encodes the business rules for request lifecycle transitions. The audit utility provides a single function every mutation will call.

Output: 8 files across 2 new modules (request, audit) providing all data layer artifacts for the request lifecycle.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-programs-dynamic-fields/02-01-SUMMARY.md
@.planning/phases/02-programs-dynamic-fields/02-02-SUMMARY.md

Key references for implementation patterns:
@server/src/modules/program/program.model.ts (Mongoose model pattern with interfaces, schema, indexes)
@server/src/modules/program/program.schema.ts (Zod schema pattern with refinements)
@server/src/shared/types.ts (shared types and Express augmentation)
@server/src/shared/errors.ts (error classes)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Request, Comment, Attachment, and AuditLog Mongoose models</name>
  <files>
    server/src/modules/request/request.model.ts
    server/src/modules/request/comment.model.ts
    server/src/modules/request/attachment.model.ts
    server/src/modules/audit/auditLog.model.ts
  </files>
  <action>
Create 4 Mongoose models following the established pattern from program.model.ts (interface, schema, indexes, export).

**Request model** (`server/src/modules/request/request.model.ts`):
- Interface `IRequestDocument extends Document` with fields:
  - `_id`: ObjectId
  - `programId`: ObjectId (ref: 'Program', required, indexed)
  - `title`: string (required, trim, 3-200 chars)
  - `description`: string (optional, trim, max 5000 chars)
  - `status`: enum from REQUEST_STATUSES constant = `['draft', 'submitted', 'in_review', 'approved', 'rejected', 'completed']` (default: 'draft', indexed)
  - `fields`: `Map<string, unknown>` -- dynamic field values stored as a Mongoose Map. Keys correspond to program fieldDefinition keys. Values are mixed type (string, number, Date, boolean, string[] for file references).
  - `createdBy`: ObjectId (ref: 'User', required, indexed)
  - `assignedTo`: ObjectId (ref: 'User', optional, indexed)
  - `priority`: enum `['low', 'medium', 'high', 'urgent']` (default: 'medium')
  - `timestamps: true` (createdAt, updatedAt)
- Indexes: `{ programId: 1, status: 1 }`, `{ programId: 1, createdAt: -1 }`, `{ assignedTo: 1, status: 1 }`, `{ createdBy: 1 }`
- Export `REQUEST_STATUSES`, `RequestStatus`, `IRequestDocument`, and the `Request` model.

**Comment model** (`server/src/modules/request/comment.model.ts`):
- Interface `ICommentDocument extends Document`:
  - `_id`: ObjectId
  - `requestId`: ObjectId (ref: 'Request', required, indexed)
  - `authorId`: ObjectId (ref: 'User', required)
  - `content`: string (required, trim, 1-5000 chars)
  - `timestamps: true`
- Indexes: `{ requestId: 1, createdAt: 1 }` (for timeline ordering)
- Export `ICommentDocument` and `Comment` model.

**Attachment model** (`server/src/modules/request/attachment.model.ts`):
- Interface `IAttachmentDocument extends Document`:
  - `_id`: ObjectId
  - `requestId`: ObjectId (ref: 'Request', required, indexed)
  - `uploadedBy`: ObjectId (ref: 'User', required)
  - `originalName`: string (required -- original filename)
  - `storagePath`: string (required -- path on disk or object key)
  - `mimeType`: string (required)
  - `size`: number (required -- bytes)
  - `timestamps: true`
- Indexes: `{ requestId: 1, createdAt: -1 }`
- Export `IAttachmentDocument` and `Attachment` model.
- Define and export `ALLOWED_MIME_TYPES` array: `['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/plain', 'text/csv']`
- Define and export `MAX_FILE_SIZE = 10 * 1024 * 1024` (10MB).

**AuditLog model** (`server/src/modules/audit/auditLog.model.ts`):
- Interface `IAuditLogDocument extends Document`:
  - `_id`: ObjectId
  - `action`: enum from AUDIT_ACTIONS = `['request.created', 'request.updated', 'request.status_changed', 'request.assigned', 'request.field_edited', 'comment.added', 'comment.deleted', 'attachment.uploaded', 'attachment.deleted']`
  - `entityType`: enum `['request', 'comment', 'attachment']`
  - `entityId`: ObjectId (required -- the request/comment/attachment ID)
  - `requestId`: ObjectId (ref: 'Request', required, indexed -- always links back to the parent request for per-request audit trail)
  - `programId`: ObjectId (ref: 'Program', required, indexed -- for admin filtering by program)
  - `performedBy`: ObjectId (ref: 'User', required)
  - `before`: Mixed (optional -- snapshot before change, stored as plain object)
  - `after`: Mixed (optional -- snapshot after change)
  - `metadata`: Mixed (optional -- extra context like transition from/to status)
  - `timestamps: true`
- Indexes: `{ requestId: 1, createdAt: -1 }` (per-request audit trail), `{ programId: 1, createdAt: -1 }` (program-level audit), `{ performedBy: 1 }`, `{ action: 1, createdAt: -1 }` (admin filtering by action type)
- Export `AUDIT_ACTIONS`, `AuditAction`, `IAuditLogDocument`, `AuditLog` model.
  </action>
  <verify>
Run `npx tsc --noEmit` from server/ directory. All 4 model files must compile without errors. Verify each file exists and exports the expected model and types.
  </verify>
  <done>
4 Mongoose models (Request, Comment, Attachment, AuditLog) compile cleanly, export correct interfaces and constants, and have appropriate indexes for query patterns used in later plans.
  </done>
</task>

<task type="auto">
  <name>Task 2: Zod validation schemas, state machine, and audit utility</name>
  <files>
    server/src/modules/request/request.schema.ts
    server/src/modules/request/stateMachine.ts
    server/src/modules/audit/audit.schema.ts
    server/src/modules/audit/audit.utils.ts
  </files>
  <action>
Create Zod schemas, state machine logic, and audit utility following established patterns from program.schema.ts.

**Request Zod schemas** (`server/src/modules/request/request.schema.ts`):
- `createRequestSchema`: body with `{ title: string (3-200), description?: string (max 5000), programId: string (MongoDB ObjectId regex validation), fields?: Record<string, unknown>, priority?: 'low'|'medium'|'high'|'urgent' }`. The `fields` object is validated at the service layer against the program's fieldDefinitions (not in Zod, since dynamic).
- `updateRequestSchema`: body with all createRequestSchema fields optional EXCEPT programId (cannot change program). Add `.refine()` to require at least one field.
- `transitionRequestSchema`: body with `{ status: z.enum(['submitted', 'in_review', 'approved', 'rejected', 'completed']) }` -- only non-draft target statuses (you can't transition TO draft).
- `assignRequestSchema`: body with `{ assignedTo: string (ObjectId regex) }`.
- `listRequestsQuerySchema`: query with `{ page: z.coerce.number().min(1).default(1), limit: z.coerce.number().min(1).max(100).default(20), status?: z.enum(REQUEST_STATUSES), assignedTo?: string, priority?: z.enum(['low','medium','high','urgent']), search?: string }`.
- `requestParamsSchema`: params with `{ programId: string (ObjectId), requestId: string (ObjectId) }`.
- Export all schemas and inferred types.

**State machine** (`server/src/modules/request/stateMachine.ts`):
- Export `VALID_TRANSITIONS` as a `Record<RequestStatus, RequestStatus[]>`:
  ```
  draft -> [submitted]
  submitted -> [in_review, rejected]
  in_review -> [approved, rejected]
  approved -> [completed]
  rejected -> [submitted]  (allows resubmission after rejection)
  completed -> []           (terminal state)
  ```
- Export `TRANSITION_ROLES`: a `Record<string, Role[]>` mapping each transition to which global roles can perform it:
  - `draft->submitted`: all roles (creator submits their own draft)
  - `submitted->in_review`: ['admin', 'manager']
  - `submitted->rejected`: ['admin', 'manager']
  - `in_review->approved`: ['admin', 'manager']
  - `in_review->rejected`: ['admin', 'manager']
  - `approved->completed`: ['admin', 'manager']
  - `rejected->submitted`: all roles (original creator can resubmit)
- Export function `canTransition(currentStatus: RequestStatus, targetStatus: RequestStatus): boolean` -- returns true if targetStatus is in VALID_TRANSITIONS[currentStatus].
- Export function `canUserTransition(currentStatus: RequestStatus, targetStatus: RequestStatus, userRole: Role): boolean` -- checks both valid transition AND role authorization.

**Audit Zod schemas** (`server/src/modules/audit/audit.schema.ts`):
- `listAuditLogsQuerySchema`: query with `{ page, limit, action?: z.enum(AUDIT_ACTIONS), entityType?: z.enum(['request','comment','attachment']), programId?: string, requestId?: string, performedBy?: string, startDate?: z.coerce.date(), endDate?: z.coerce.date() }`.
- Export schema and inferred type.

**Audit utility** (`server/src/modules/audit/audit.utils.ts`):
- Export async function `createAuditEntry(data: { action: AuditAction, entityType: 'request' | 'comment' | 'attachment', entityId: string, requestId: string, programId: string, performedBy: string, before?: unknown, after?: unknown, metadata?: Record<string, unknown> }): Promise<IAuditLogDocument>`.
- Implementation: `AuditLog.create(data)` -- simple wrapper, but centralizes audit creation so all callers use the same interface. Log errors with winston logger but do NOT throw (audit failures should not break the main operation -- fire-and-forget pattern consistent with project philosophy).
- Import logger from `../../config/logger.js`.
  </action>
  <verify>
Run `npx tsc --noEmit` from server/ directory. All 4 files must compile cleanly. Verify `canTransition('draft', 'submitted')` returns true and `canTransition('draft', 'approved')` returns false by inspection of the VALID_TRANSITIONS map.
  </verify>
  <done>
Zod schemas validate all request/audit inputs. State machine encodes the complete lifecycle with role-based transition authorization. Audit utility provides a fire-and-forget function for every mutation to call. All files compile without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes from server/ with zero errors
2. All 8 files exist in correct module directories
3. Request model has programId ref, status enum, fields Map, assignedTo ref
4. AuditLog model has requestId + programId indexes for both per-request and admin views
5. State machine VALID_TRANSITIONS covers all 7 transitions from the lifecycle
6. Audit utility catches errors without throwing (fire-and-forget)
</verification>

<success_criteria>
- 4 Mongoose models (Request, Comment, Attachment, AuditLog) with correct interfaces, schemas, and indexes
- Zod validation schemas for request CRUD, transitions, assignment, and audit log listing
- State machine with transition map and role-based authorization
- Audit utility function ready for use by all mutation operations in Plans 02 and 03
- Zero TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-request-lifecycle-audit/03-01-SUMMARY.md`
</output>
