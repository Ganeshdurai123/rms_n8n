---
phase: 03-request-lifecycle-audit
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - server/src/modules/request/comment.service.ts
  - server/src/modules/request/comment.controller.ts
  - server/src/modules/request/comment.routes.ts
  - server/src/modules/request/comment.schema.ts
  - server/src/modules/request/attachment.service.ts
  - server/src/modules/request/attachment.controller.ts
  - server/src/modules/request/attachment.routes.ts
  - server/src/modules/request/attachment.schema.ts
  - server/src/modules/request/requestDetail.service.ts
  - server/src/modules/audit/audit.service.ts
  - server/src/modules/audit/audit.controller.ts
  - server/src/modules/audit/audit.routes.ts
  - server/src/modules/request/request.routes.ts
  - server/src/app.ts
  - server/package.json
autonomous: true
requirements:
  - REQ-06
  - REQ-07
  - REQ-08
  - REQ-09
  - REQ-11
  - AUDIT-01
  - AUDIT-02
  - AUDIT-03

must_haves:
  truths:
    - "User can add comments to a request and see them in chronological order"
    - "User can upload file attachments with type and size validation"
    - "User can download file attachments from a request"
    - "Request detail endpoint returns all fields, comments, attachments, and audit history"
    - "Admin can view system-wide audit log with filtering by action, entity, program, date range"
    - "Users can view per-request audit trail showing all changes"
  artifacts:
    - path: "server/src/modules/request/comment.service.ts"
      provides: "Comment CRUD with audit logging"
      exports: ["addComment", "getComments", "deleteComment"]
    - path: "server/src/modules/request/attachment.service.ts"
      provides: "File upload/download with validation and audit logging"
      exports: ["uploadAttachment", "getAttachments", "downloadAttachment", "deleteAttachment"]
    - path: "server/src/modules/request/requestDetail.service.ts"
      provides: "Aggregated request detail with comments, attachments, and audit trail"
      exports: ["getRequestDetail"]
    - path: "server/src/modules/audit/audit.service.ts"
      provides: "Admin audit log listing with filters"
      exports: ["getAuditLogs", "getRequestAuditTrail"]
    - path: "server/src/modules/audit/audit.routes.ts"
      provides: "Admin audit log API routes"
      contains: "router"
  key_links:
    - from: "server/src/modules/request/comment.service.ts"
      to: "server/src/modules/audit/audit.utils.ts"
      via: "createAuditEntry on add/delete"
      pattern: "createAuditEntry"
    - from: "server/src/modules/request/attachment.service.ts"
      to: "server/src/modules/audit/audit.utils.ts"
      via: "createAuditEntry on upload/delete"
      pattern: "createAuditEntry"
    - from: "server/src/modules/request/requestDetail.service.ts"
      to: "Comment, Attachment, AuditLog models"
      via: "parallel queries for aggregated detail"
      pattern: "Promise\\.all"
    - from: "server/src/app.ts"
      to: "server/src/modules/audit/audit.routes.ts"
      via: "app.use mount for admin audit endpoint"
      pattern: "app\\.use.*auditRouter"
---

<objective>
Complete the request lifecycle feature set: comments, file attachments, request detail aggregation, and audit log views. This plan adds the collaboration and visibility layers that make request management useful.

Purpose: Users need to discuss requests (comments), attach supporting documents (files), view everything in one place (request detail), and administrators need a system-wide audit trail. This plan delivers all four capabilities.

Output: 15 files across request and audit modules providing comment CRUD, file upload/download, aggregated request detail, and admin audit log API.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-request-lifecycle-audit/03-01-SUMMARY.md
@.planning/phases/03-request-lifecycle-audit/03-02-SUMMARY.md

Key references:
@server/src/modules/request/comment.model.ts (Comment model from Plan 01)
@server/src/modules/request/attachment.model.ts (Attachment model from Plan 01)
@server/src/modules/audit/auditLog.model.ts (AuditLog model from Plan 01)
@server/src/modules/audit/audit.utils.ts (audit utility from Plan 01)
@server/src/modules/audit/audit.schema.ts (audit query schema from Plan 01)
@server/src/modules/request/request.routes.ts (request routes from Plan 02)
@server/src/modules/request/request.service.ts (request service from Plan 02)
@server/src/modules/program/program.service.ts (service pattern reference)
@server/src/middleware/authorizeProgram.ts (program authorization)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Comment CRUD with schemas, service, controller, and routes</name>
  <files>
    server/src/modules/request/comment.schema.ts
    server/src/modules/request/comment.service.ts
    server/src/modules/request/comment.controller.ts
    server/src/modules/request/comment.routes.ts
    server/src/modules/request/request.routes.ts
  </files>
  <action>
Build the comment sub-resource API nested under requests.

**Comment Zod schemas** (`server/src/modules/request/comment.schema.ts`):
- `addCommentSchema`: body with `{ content: z.string().trim().min(1).max(5000) }`.
- `listCommentsQuerySchema`: query with `{ page: z.coerce.number().min(1).default(1), limit: z.coerce.number().min(1).max(100).default(50) }` -- higher default limit for timeline.
- `commentParamsSchema`: params with `{ programId: string (ObjectId regex), requestId: string (ObjectId regex), commentId: string (ObjectId regex) }`.
- Export all schemas and inferred types.

**Comment service** (`server/src/modules/request/comment.service.ts`):
- `addComment(requestId: string, content: string, authorId: string, programId: string)`:
  - Verify request exists via `Request.findById(requestId)`. Throw NotFoundError if not.
  - Create Comment document.
  - Call `createAuditEntry({ action: 'comment.added', entityType: 'comment', entityId: comment._id, requestId, programId, performedBy: authorId, after: { content } })`.
  - Return comment populated with `authorId` -> `firstName lastName email`.

- `getComments(requestId: string, query)`:
  - Paginate comments for the request, sorted by `createdAt` ascending (timeline order -- oldest first).
  - Populate `authorId` with `firstName lastName email`.
  - Return `{ comments, total, page, limit }`.

- `deleteComment(commentId: string, requestId: string, userId: string, userRole: Role, programId: string)`:
  - Fetch comment. Verify it exists and belongs to the request.
  - Only the comment author or an admin/manager can delete: check `comment.authorId.toString() === userId || ['admin', 'manager'].includes(userRole)`.
  - Throw ForbiddenError if not authorized.
  - Delete the comment.
  - Call `createAuditEntry({ action: 'comment.deleted', entityType: 'comment', entityId: commentId, requestId, programId, performedBy: userId, before: { content: comment.content, authorId: comment.authorId } })`.

**Comment controller** (`server/src/modules/request/comment.controller.ts`):
- `add`: Extract body.content, call addComment, respond 201.
- `list`: Extract query, call getComments, respond 200 with paginatedResponse.
- `remove`: Call deleteComment, respond 204 (no content).
All wrapped in try/catch with next(err).

**Comment routes** (`server/src/modules/request/comment.routes.ts`):
```
const router = Router({ mergeParams: true });
// No auth middleware here -- inherited from parent request router

POST /  -> validate(addCommentSchema) -> add
GET /   -> validate(listCommentsQuerySchema, 'query') -> list
DELETE /:commentId -> validate(commentParamsSchema, 'params') -> remove
```
Export `commentRouter`.

**Update request.routes.ts:**
- Import `commentRouter` from `./comment.routes.js`.
- Mount: `router.use('/:requestId/comments', commentRouter)` -- AFTER the requestId-level routes.
- This nests comments under `/api/v1/programs/:programId/requests/:requestId/comments`.
  </action>
  <verify>
Run `npx tsc --noEmit` from server/. All comment files compile. Verify commentRouter is mounted in request.routes.ts. Verify audit logging calls in addComment and deleteComment.
  </verify>
  <done>
Comment CRUD API functional at /programs/:programId/requests/:requestId/comments. Comments are created, listed in timeline order, and deletable by author or admin/manager. Every comment add/delete creates an audit entry.
  </done>
</task>

<task type="auto">
  <name>Task 2: File attachment upload/download with multer, schemas, service, controller, and routes</name>
  <files>
    server/src/modules/request/attachment.schema.ts
    server/src/modules/request/attachment.service.ts
    server/src/modules/request/attachment.controller.ts
    server/src/modules/request/attachment.routes.ts
    server/src/modules/request/request.routes.ts
    server/package.json
  </files>
  <action>
Build the file attachment sub-resource API with multer for multipart file uploads.

**Install multer:**
Run `npm install multer @types/multer` in server/ directory. multer handles multipart/form-data parsing for file uploads.

**Attachment Zod schemas** (`server/src/modules/request/attachment.schema.ts`):
- `listAttachmentsQuerySchema`: query with `{ page: z.coerce.number().min(1).default(1), limit: z.coerce.number().min(1).max(100).default(20) }`.
- `attachmentParamsSchema`: params with `{ programId: string (ObjectId regex), requestId: string (ObjectId regex), attachmentId: string (ObjectId regex) }`.
- Export schemas and types.

**Attachment service** (`server/src/modules/request/attachment.service.ts`):
- `uploadAttachment(requestId: string, file: Express.Multer.File, uploadedBy: string, programId: string)`:
  - Verify request exists via Request.findById.
  - Validate file: check `ALLOWED_MIME_TYPES.includes(file.mimetype)`, throw ValidationError if not.
  - Check `file.size <= MAX_FILE_SIZE`, throw ValidationError if exceeds (multer limit should also catch this, but double-check).
  - Create Attachment document with `originalName: file.originalname`, `storagePath: file.path` (relative to uploads dir), `mimeType: file.mimetype`, `size: file.size`.
  - Call `createAuditEntry({ action: 'attachment.uploaded', entityType: 'attachment', entityId: attachment._id, requestId, programId, performedBy: uploadedBy, after: { originalName: file.originalname, mimeType: file.mimetype, size: file.size } })`.
  - Return attachment.

- `getAttachments(requestId: string, query)`:
  - Paginate attachments for the request, sorted by `createdAt` descending (newest first).
  - Populate `uploadedBy` with `firstName lastName email`.
  - Return `{ attachments, total, page, limit }`.

- `getAttachmentById(attachmentId: string, requestId: string)`:
  - Find attachment by ID and requestId. Throw NotFoundError if not found.
  - Return attachment (for download controller to use storagePath).

- `deleteAttachment(attachmentId: string, requestId: string, userId: string, userRole: Role, programId: string)`:
  - Fetch attachment. Verify exists and belongs to request.
  - Only uploader or admin/manager can delete.
  - Delete the file from disk using `fs.promises.unlink(attachment.storagePath)` -- wrapped in try/catch to not throw if file already gone.
  - Delete the Attachment document.
  - Call `createAuditEntry({ action: 'attachment.deleted', entityType: 'attachment', entityId: attachmentId, requestId, programId, performedBy: userId, before: { originalName: attachment.originalName } })`.

**Configure multer storage:**
In the attachment service file (or a separate config if preferred), configure multer:
```typescript
import multer from 'multer';
import path from 'path';
import { nanoid } from 'nanoid';

const uploadDir = path.join(process.cwd(), 'uploads');

const storage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    cb(null, uploadDir);
  },
  filename: (_req, file, cb) => {
    // Unique filename: nanoid + original extension
    const ext = path.extname(file.originalname);
    cb(null, `${nanoid()}-${Date.now()}${ext}`);
  },
});

export const upload = multer({
  storage,
  limits: { fileSize: MAX_FILE_SIZE },
  fileFilter: (_req, file, cb) => {
    if (ALLOWED_MIME_TYPES.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new AppError(`File type ${file.mimetype} is not allowed`, 400) as unknown as Error);
    }
  },
});
```

**IMPORTANT:** Create the `uploads/` directory in the server root if it doesn't exist. Add a `.gitkeep` file inside. Add `uploads/*` and `!uploads/.gitkeep` to `.gitignore` (or verify it's already ignored).

**Attachment controller** (`server/src/modules/request/attachment.controller.ts`):
- `uploadFile`: `upload.single('file')` is applied as middleware in routes. Controller extracts `req.file`, calls `uploadAttachment`, responds 201.
- `list`: Call getAttachments, respond 200 with paginatedResponse.
- `download`: Call getAttachmentById, use `res.download(attachment.storagePath, attachment.originalName)` to stream the file with the original filename.
- `remove`: Call deleteAttachment, respond 204.
All wrapped in try/catch.

**Attachment routes** (`server/src/modules/request/attachment.routes.ts`):
```
const router = Router({ mergeParams: true });

POST /   -> upload.single('file') -> uploadFile
GET /    -> validate(listAttachmentsQuerySchema, 'query') -> list
GET /:attachmentId -> validate(attachmentParamsSchema, 'params') -> download
DELETE /:attachmentId -> validate(attachmentParamsSchema, 'params') -> remove
```
Export `attachmentRouter`.

**Update request.routes.ts:**
- Import `attachmentRouter` from `./attachment.routes.js`.
- Mount: `router.use('/:requestId/attachments', attachmentRouter)` -- after comment mount.

**Ensure uploads directory exists:**
Create `server/uploads/.gitkeep`. Add `uploads/*` and `!uploads/.gitkeep` to `server/.gitignore` if not already present.
  </action>
  <verify>
Run `npx tsc --noEmit` from server/. All attachment files compile. Verify multer is in package.json dependencies. Verify attachmentRouter is mounted in request.routes.ts. Verify upload directory setup.
  </verify>
  <done>
File attachment upload/download API functional at /programs/:programId/requests/:requestId/attachments. Files validated for type and size, stored on disk with unique names, downloadable with original filename. Upload/delete audited.
  </done>
</task>

<task type="auto">
  <name>Task 3: Request detail aggregation, admin audit log API, and per-request audit trail</name>
  <files>
    server/src/modules/request/requestDetail.service.ts
    server/src/modules/audit/audit.service.ts
    server/src/modules/audit/audit.controller.ts
    server/src/modules/audit/audit.routes.ts
    server/src/modules/request/request.controller.ts
    server/src/modules/request/request.routes.ts
    server/src/app.ts
  </files>
  <action>
Build the aggregated request detail endpoint and admin audit log API.

**Request detail service** (`server/src/modules/request/requestDetail.service.ts`):
- `getRequestDetail(requestId: string)`:
  - Run 4 parallel queries using `Promise.all`:
    1. `Request.findById(requestId).populate('createdBy', 'firstName lastName email').populate('assignedTo', 'firstName lastName email').populate('programId', 'name fieldDefinitions').lean()`
    2. `Comment.find({ requestId }).populate('authorId', 'firstName lastName email').sort({ createdAt: 1 }).lean()` -- all comments (no pagination for detail view)
    3. `Attachment.find({ requestId }).populate('uploadedBy', 'firstName lastName email').sort({ createdAt: -1 }).lean()` -- all attachments
    4. `AuditLog.find({ requestId }).populate('performedBy', 'firstName lastName email').sort({ createdAt: -1 }).lean()` -- full audit trail
  - If request not found, throw NotFoundError.
  - Return `{ request, comments, attachments, auditTrail }`.

**Audit service** (`server/src/modules/audit/audit.service.ts`):
- `getAuditLogs(query: ListAuditLogsQuery)`:
  - Build filter from query params: action, entityType, programId, requestId, performedBy.
  - If startDate/endDate provided, add `createdAt: { $gte: startDate, $lte: endDate }`.
  - Paginate, sort by createdAt descending.
  - Populate `performedBy` with `firstName lastName email`.
  - Populate `requestId` with `title` (for context in the admin view).
  - Return `{ auditLogs, total, page, limit }`.

- `getRequestAuditTrail(requestId: string, query)`:
  - Simple paginated query: `AuditLog.find({ requestId })`.
  - Populate performedBy.
  - Sort by createdAt descending.
  - Return `{ auditLogs, total, page, limit }`.

**Audit controller** (`server/src/modules/audit/audit.controller.ts`):
- `listAuditLogs`: Call getAuditLogs, respond 200 with paginatedResponse.
- `listRequestAuditTrail`: Call getRequestAuditTrail, respond 200 with paginatedResponse.

**Audit routes** (`server/src/modules/audit/audit.routes.ts`):
```
const router = Router();

// Admin-only audit log view
router.use(authenticate);
router.use(authorize('admin'));

GET /  -> validate(listAuditLogsQuerySchema, 'query') -> listAuditLogs
```
Export `auditRouter`.

**Update request.controller.ts:**
- Add `getDetail` controller method that calls `getRequestDetail(req.params.requestId)` and responds 200 with `{ data: result }`.

**Update request.routes.ts:**
- Add route: `GET /:requestId/detail` -> `validate(requestParamsSchema, 'params')` -> `getDetail` -- this is the aggregated detail endpoint (REQ-11).
- Add route: `GET /:requestId/audit` -> `validate(requestParamsSchema, 'params')` -> audit trail endpoint. Create inline controller or import from audit controller. This returns the per-request audit trail (AUDIT-03) accessible to any program member (not admin-only).
  - For the per-request audit trail: import `getRequestAuditTrail` from audit.service.ts and add a `getAuditTrail` controller in request.controller.ts that calls it.

**Update app.ts:**
- Import `auditRouter` from `./modules/audit/audit.routes.js`.
- Mount: `app.use('/api/v1/admin/audit', auditRouter)` -- admin namespace, before 404 handler.

**Route summary after all mounts:**
```
/api/v1/programs/:programId/requests                    -- CRUD (Plan 02)
/api/v1/programs/:programId/requests/:requestId/transition  -- status (Plan 02)
/api/v1/programs/:programId/requests/:requestId/assign      -- assign (Plan 02)
/api/v1/programs/:programId/requests/:requestId/comments    -- comments (Task 1)
/api/v1/programs/:programId/requests/:requestId/attachments -- files (Task 2)
/api/v1/programs/:programId/requests/:requestId/detail      -- aggregated detail (Task 3)
/api/v1/programs/:programId/requests/:requestId/audit       -- per-request audit (Task 3)
/api/v1/admin/audit                                         -- admin audit log (Task 3)
```
  </action>
  <verify>
Run `npx tsc --noEmit` from server/. All files compile. Verify app.ts has auditRouter mounted at /api/v1/admin/audit. Verify request detail endpoint returns request + comments + attachments + auditTrail. Verify admin audit log requires admin role.
  </verify>
  <done>
Request detail page data available at GET /requests/:requestId/detail with all fields, comments, attachments, and history. Admin-only audit log at /api/v1/admin/audit with full filtering. Per-request audit trail at /requests/:requestId/audit for any program member. All audit requirements (AUDIT-01, AUDIT-02, AUDIT-03) satisfied.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes from server/ with zero errors
2. Comments can be added/listed/deleted with audit logging
3. File attachments can be uploaded (multer), listed, downloaded, and deleted with type/size validation
4. Request detail endpoint returns aggregated data (request + comments + attachments + audit trail)
5. Admin audit log at /api/v1/admin/audit supports filtering by action, entity, program, date range
6. Per-request audit trail at /requests/:requestId/audit accessible to program members
7. multer and @types/multer are in package.json
8. uploads/ directory exists with .gitkeep
</verification>

<success_criteria>
- Comment CRUD with timeline ordering and audit logging
- File upload with multer, MIME type validation, size validation, unique filenames
- File download streaming with original filename
- Aggregated request detail returning request + comments + attachments + full audit trail
- Admin-only system-wide audit log with filtering
- Per-request audit trail for any program member
- All 8 Phase 3 requirement IDs covered by this plan are satisfied
- Zero TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-request-lifecycle-audit/03-03-SUMMARY.md`
</output>
