---
phase: 05-n8n-integration-notifications
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/modules/notification/notification.model.ts
  - server/src/modules/notification/notification.schema.ts
  - server/src/modules/notification/notification.service.ts
  - server/src/modules/notification/notification.controller.ts
  - server/src/modules/notification/notification.routes.ts
  - server/src/shared/socketEvents.ts
  - server/src/app.ts
autonomous: true
requirements:
  - NOTIF-01
  - NOTIF-02
  - NOTIF-04

must_haves:
  truths:
    - "User receives in-app notifications stored in database with unread count"
    - "In-app notifications update in real-time via Socket.IO when created"
    - "User can mark individual notifications as read or unread"
    - "User can list their notifications with pagination and unread count"
  artifacts:
    - path: "server/src/modules/notification/notification.model.ts"
      provides: "Notification Mongoose model with userId, type, read status"
      contains: "model Notification"
    - path: "server/src/modules/notification/notification.service.ts"
      provides: "Notification CRUD operations and real-time emission"
      exports: ["createNotification", "getNotifications", "getUnreadCount", "markAsRead", "markAsUnread"]
    - path: "server/src/modules/notification/notification.routes.ts"
      provides: "Notification REST API routes"
      exports: ["notificationRouter"]
    - path: "server/src/shared/socketEvents.ts"
      provides: "Updated event catalog with notification events"
      contains: "notification:created"
  key_links:
    - from: "server/src/modules/notification/notification.service.ts"
      to: "server/src/config/socket.ts"
      via: "getIO() for targeted user notification emission"
      pattern: "getIO\\(\\)"
    - from: "server/src/app.ts"
      to: "server/src/modules/notification/notification.routes.ts"
      via: "app.use('/api/v1/notifications', notificationRouter)"
      pattern: "notificationRouter"
---

<objective>
Create the in-app notification system with Mongoose model, REST API for listing/marking notifications, and real-time Socket.IO delivery when new notifications are created.

Purpose: Provides the notification bell + unread count experience so users are alerted about status changes, assignments, and comments without polling. The notification model is also used by Plan 05-04's n8n workflows to create notifications via the internal API.

Output: Notification model, service with CRUD + real-time push, controller, routes, updated socketEvents.ts with notification event type.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@server/src/shared/socketEvents.ts
@server/src/config/socket.ts
@server/src/shared/errors.ts
@server/src/middleware/authenticate.ts
@server/src/middleware/pagination.ts
@server/src/app.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Notification model, Zod schemas, and service with real-time emission</name>
  <files>
    server/src/modules/notification/notification.model.ts
    server/src/modules/notification/notification.schema.ts
    server/src/modules/notification/notification.service.ts
    server/src/shared/socketEvents.ts
  </files>
  <action>
    Create `server/src/modules/notification/` directory with three files, plus update socketEvents.ts:

    **notification.model.ts** — Mongoose model:
    - Define `NOTIFICATION_TYPES` as const array: `['request.status_changed', 'request.assigned', 'request.created', 'request.updated', 'comment.added', 'attachment.uploaded', 'reminder']`. These cover all notification-triggering events.
    - Define `NotificationType` as union from the const array.
    - Define `INotificationDocument` extending Document: `userId` (ObjectId, ref User, required, indexed), `type` (NotificationType, required), `title` (string, required), `message` (string, required), `isRead` (boolean, default false), `programId` (ObjectId, ref Program, optional), `requestId` (ObjectId, ref Request, optional), `metadata` (Mixed, optional), `createdAt`, `updatedAt`.
    - Create schema with `timestamps: true`.
    - Indexes: `{ userId: 1, isRead: 1, createdAt: -1 }` (list query), `{ userId: 1, isRead: 1 }` (unread count).
    - Export `Notification` model and types.

    **notification.schema.ts** — Zod validation schemas:
    - `listNotificationsSchema`: query params with `page` (default 1), `limit` (default 20), `isRead` (optional boolean).
    - `markNotificationSchema`: params with `notificationId` (string).
    - Export inferred types.

    **notification.service.ts** — Service functions:
    - `createNotification(data: { userId: string; type: NotificationType; title: string; message: string; programId?: string; requestId?: string; metadata?: Record<string, unknown> }): Promise<INotificationDocument | null>` — Creates notification in DB. After creation, emits a Socket.IO event directly to the target user. Use `getIO()` from config/socket.ts. To target a specific user (not a program room), iterate over all sockets via `io.sockets.sockets` and find sockets where `socket.data.userId === data.userId`, then emit `notification:created` to each. This is fire-and-forget: wrap in try/catch, log errors, never throw.
    - `getNotifications(userId: string, query: { page: number; limit: number; isRead?: boolean }): Promise<{ notifications: INotificationDocument[]; total: number; page: number; limit: number }>` — Paginated notifications for user, sorted by createdAt descending (newest first). Filter by isRead if provided.
    - `getUnreadCount(userId: string): Promise<number>` — Count of unread notifications for user.
    - `markAsRead(notificationId: string, userId: string): Promise<INotificationDocument>` — Set isRead=true. Verify notification belongs to userId. Throw NotFoundError if not found. Throw ForbiddenError if userId mismatch.
    - `markAsUnread(notificationId: string, userId: string): Promise<INotificationDocument>` — Set isRead=false. Same ownership verification.
    - `markAllAsRead(userId: string): Promise<number>` — Bulk mark all unread notifications as read for user. Return count of updated docs.

    **socketEvents.ts** — Update the existing file:
    - Add `'notification:created'` to the `SocketEventName` union type.
    - Add `'notification:created': (payload: SocketEventPayload) => void;` to `ServerToClientEvents` interface.
    - Do NOT change any existing event definitions.
  </action>
  <verify>
    Run `cd server && npx tsc --noEmit` -- TypeScript compiles. Verify notification.model.ts exports `Notification` model. Verify socketEvents.ts includes `notification:created`.
  </verify>
  <done>
    Notification model stores per-user notifications with type, read status, and optional program/request references. Service creates notifications and pushes them via Socket.IO to the specific user in real-time. Unread count query is efficient via dedicated index.
  </done>
</task>

<task type="auto">
  <name>Task 2: Notification REST API routes and app mounting</name>
  <files>
    server/src/modules/notification/notification.controller.ts
    server/src/modules/notification/notification.routes.ts
    server/src/app.ts
  </files>
  <action>
    **notification.controller.ts** — Controller functions:
    - `listNotifications`: Calls `getNotifications(req.user._id, query)`. Returns paginated response using the same shape as other list endpoints: `{ data: notifications, meta: { total, page, limit } }`.
    - `unreadCount`: Calls `getUnreadCount(req.user._id)`. Returns `{ count: number }`.
    - `markRead`: Calls `markAsRead(req.params.notificationId, req.user._id)`. Returns updated notification.
    - `markUnread`: Calls `markAsUnread(req.params.notificationId, req.user._id)`. Returns updated notification.
    - `markAllRead`: Calls `markAllAsRead(req.user._id)`. Returns `{ updated: count }`.
    - All handlers wrapped in try/catch with next(error) pattern (matching existing controller patterns).

    **notification.routes.ts** — Express router:
    - Import `authenticate` middleware from `../../middleware/authenticate.js`.
    - Apply `authenticate` to all routes via `router.use(authenticate)`.
    - `GET /` -> listNotifications (with validate middleware for listNotificationsSchema on query).
    - `GET /unread-count` -> unreadCount.
    - `PATCH /:notificationId/read` -> markRead (with validate middleware for markNotificationSchema on params).
    - `PATCH /:notificationId/unread` -> markUnread.
    - `PATCH /read-all` -> markAllRead. NOTE: Mount this BEFORE the `/:notificationId/*` routes to avoid `read-all` being parsed as a notificationId.
    - Export `notificationRouter`.

    **app.ts** — Mount notification routes:
    - Add import: `import { notificationRouter } from './modules/notification/notification.routes.js';`
    - Mount BEFORE the 404 handler: `app.use('/api/v1/notifications', notificationRouter);`
    - Place after the existing program and request route mounts (line ordering: programs, requests, audit, notifications, internal, 404).

    Important: All notification endpoints require authentication (JWT) but NOT role-based authorization -- every authenticated user can manage their own notifications.
  </action>
  <verify>
    Run `cd server && npx tsc --noEmit` -- TypeScript compiles. Verify app.ts imports and mounts notificationRouter. Verify routes: GET /, GET /unread-count, PATCH /:notificationId/read, PATCH /:notificationId/unread, PATCH /read-all.
  </verify>
  <done>
    Notification REST API is accessible at /api/v1/notifications with full CRUD: list (paginated, filterable by read status), unread count, mark read, mark unread, mark all read. All endpoints require JWT authentication. Routes mounted in app.ts.
  </done>
</task>

</tasks>

<verification>
1. `cd server && npx tsc --noEmit` passes with zero errors
2. All 5 new files exist under server/src/modules/notification/
3. socketEvents.ts includes `notification:created` in both SocketEventName and ServerToClientEvents
4. app.ts mounts notificationRouter at /api/v1/notifications
5. Notification model has indexes on { userId, isRead, createdAt } and { userId, isRead }
6. createNotification emits to specific user sockets via Socket.IO
7. markAsRead/markAsUnread verify notification ownership (userId match)
</verification>

<success_criteria>
- Notification model stores per-user notifications with type, read status, and program/request references
- REST API provides list, unread count, mark read, mark unread, and mark all read
- Real-time Socket.IO emission targets the specific recipient user, not program rooms
- All endpoints require JWT authentication but not role-based authorization
- TypeScript compiles with strict mode
</success_criteria>

<output>
After completion, create `.planning/phases/05-n8n-integration-notifications/05-02-SUMMARY.md`
</output>
