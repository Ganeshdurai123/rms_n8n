---
phase: 05-n8n-integration-notifications
plan: 03
type: execute
wave: 2
depends_on:
  - 05-01
  - 05-02
files_modified:
  - server/src/modules/request/request.service.ts
  - server/src/modules/request/comment.service.ts
  - server/src/modules/request/attachment.service.ts
  - server/src/server.ts
autonomous: true
requirements:
  - N8N-01

must_haves:
  truths:
    - "Every mutation in Express fires a webhook event to the outbox for n8n delivery"
    - "Webhook events include typed payloads with all mutation context"
    - "In-app notifications are created for relevant users on status changes, assignments, and comments"
    - "Outbox processor starts on server boot and dispatches pending events to n8n"
  artifacts:
    - path: "server/src/modules/request/request.service.ts"
      provides: "Request mutations enqueue webhook events and create notifications"
      contains: "enqueueWebhookEvent"
    - path: "server/src/modules/request/comment.service.ts"
      provides: "Comment mutations enqueue webhook events and create notifications"
      contains: "enqueueWebhookEvent"
    - path: "server/src/modules/request/attachment.service.ts"
      provides: "Attachment mutations enqueue webhook events"
      contains: "enqueueWebhookEvent"
    - path: "server/src/server.ts"
      provides: "Outbox processor starts on server boot"
      contains: "startOutboxProcessor"
  key_links:
    - from: "server/src/modules/request/request.service.ts"
      to: "server/src/modules/webhook/webhook.service.ts"
      via: "enqueueWebhookEvent call after each mutation"
      pattern: "enqueueWebhookEvent"
    - from: "server/src/modules/request/request.service.ts"
      to: "server/src/modules/notification/notification.service.ts"
      via: "createNotification for assignees and stakeholders"
      pattern: "createNotification"
    - from: "server/src/server.ts"
      to: "server/src/modules/webhook/webhook.service.ts"
      via: "startOutboxProcessor() on server start"
      pattern: "startOutboxProcessor"
---

<objective>
Wire webhook dispatch and in-app notification creation into all 8 mutation paths (request CRUD, status transitions, assignments, comments, attachments), and start the outbox processor on server boot.

Purpose: This is the integration layer that connects every mutation to both n8n (via webhook outbox) and the notification system (via createNotification). Without this wiring, the infrastructure from Plans 01 and 02 would be unused.

Output: Updated service files with webhook + notification calls, updated server.ts with outbox processor startup.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-n8n-integration-notifications/05-01-SUMMARY.md
@.planning/phases/05-n8n-integration-notifications/05-02-SUMMARY.md
@server/src/modules/request/request.service.ts
@server/src/modules/request/comment.service.ts
@server/src/modules/request/attachment.service.ts
@server/src/modules/webhook/webhook.service.ts
@server/src/modules/webhook/webhook.types.ts
@server/src/modules/notification/notification.service.ts
@server/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire webhook dispatch and notifications into all mutation paths</name>
  <files>
    server/src/modules/request/request.service.ts
    server/src/modules/request/comment.service.ts
    server/src/modules/request/attachment.service.ts
  </files>
  <action>
    Add webhook enqueue and notification creation to every mutation function across three service files. Follow the existing fire-and-forget pattern (`.then().catch(() => {})`) already used for Socket.IO emissions.

    **request.service.ts** — Add imports for `enqueueWebhookEvent` from `../webhook/webhook.service.js` and `createNotification` from `../notification/notification.service.js`. Modify 4 functions:

    1. `createRequest()`: After the existing `emitToProgram` block, add:
       - `enqueueWebhookEvent('request.created', { eventType: 'request.created', programId: data.programId, requestId: request._id.toString(), data: { request: request.toObject() }, performedBy: performer, timestamp: new Date().toISOString() })` — but since performer is resolved async, chain this inside the existing `.then()` block OR resolve performer first and reuse. Preferred approach: resolve `getPerformerName(userId)` into a variable with `.then()`, then inside that block call both `emitToProgram` AND `enqueueWebhookEvent`. This avoids double DB lookups.
       - No notification for request creation (creator doesn't need to notify themselves).

    2. `updateRequest()`: Inside the existing fire-and-forget block, add `enqueueWebhookEvent` with eventType `request.updated`.
       - No notification (only draft requests can be updated, by creator).

    3. `transitionRequest()`: Inside the existing fire-and-forget block, add `enqueueWebhookEvent` with eventType `request.status_changed`.
       - Create notifications for: (a) the request creator (if they didn't perform the transition), (b) the assignee (if different from performer). Title: `"Request status changed"`. Message: `"Request \"${request.title}\" moved from ${beforeStatus} to ${targetStatus}"`.

    4. `assignRequest()`: Inside the existing fire-and-forget block, add `enqueueWebhookEvent` with eventType `request.assigned`.
       - Create notification for the assignee (assignedToUserId): Title: `"Request assigned to you"`. Message: `"You have been assigned to \"${request.title}\""`. Include programId and requestId in notification metadata.

    **comment.service.ts** — Add imports for `enqueueWebhookEvent` and `createNotification`. Modify 2 functions:

    1. `addComment()`: Inside the existing fire-and-forget block, add `enqueueWebhookEvent` with eventType `comment.added`.
       - Create notification for: the request creator (if different from comment author). To get the request creator, use the `request` variable already fetched at the top of the function. Title: `"New comment on your request"`. Message: `"${performer.name} commented on \"${request.title}\""`.

    2. `deleteComment()`: Inside the existing fire-and-forget block, add `enqueueWebhookEvent` with eventType `comment.deleted`.
       - No notification for comment deletion.

    **attachment.service.ts** — Add imports for `enqueueWebhookEvent`. Modify 2 functions:

    1. `uploadAttachment()`: Inside the existing fire-and-forget block, add `enqueueWebhookEvent` with eventType `attachment.uploaded`.
       - No notification for attachment upload (low signal-to-noise).

    2. `deleteAttachment()`: Inside the existing fire-and-forget block, add `enqueueWebhookEvent` with eventType `attachment.deleted`.
       - No notification for attachment deletion.

    **Pattern for webhook enqueue within existing fire-and-forget blocks:**
    The existing pattern is:
    ```
    getPerformerName(userId).then((performer) => {
      emitToProgram(...);
    }).catch(() => {});
    ```
    Update to:
    ```
    getPerformerName(userId).then((performer) => {
      emitToProgram(...);
      enqueueWebhookEvent(eventType, { eventType, programId, requestId, data: {...}, performedBy: performer, timestamp: new Date().toISOString() });
      // Notifications where applicable:
      if (shouldNotify) {
        createNotification({ userId: targetUserId, type: eventType, title: '...', message: '...', programId, requestId });
      }
    }).catch(() => {});
    ```

    All webhook and notification calls are fire-and-forget — they must NEVER break or delay the HTTP response. The `enqueueWebhookEvent` and `createNotification` functions already handle errors internally.
  </action>
  <verify>
    Run `cd server && npx tsc --noEmit` -- TypeScript compiles. Grep for `enqueueWebhookEvent` in all three service files to confirm 8 total calls (createRequest, updateRequest, transitionRequest, assignRequest, addComment, deleteComment, uploadAttachment, deleteAttachment). Grep for `createNotification` in request.service.ts and comment.service.ts.
  </verify>
  <done>
    All 8 mutation paths enqueue webhook events to the outbox. Status changes, assignments, and comments create in-app notifications for relevant users. All calls are fire-and-forget within existing async blocks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Start outbox processor on server boot</name>
  <files>
    server/src/server.ts
  </files>
  <action>
    **server.ts** — Start the outbox processor during server boot:
    - Add import: `import { startOutboxProcessor, stopOutboxProcessor } from './modules/webhook/webhook.service.js';`
    - In the `start()` function, after Socket.IO initialization (step 4.5), add step 4.6:
      ```
      // 4.6. Start webhook outbox processor
      const outboxHandle = startOutboxProcessor(10_000); // Process every 10 seconds
      logger.info('Webhook outbox processor started');
      ```
    - Store `outboxHandle` in module scope so the shutdown handler can clear it.
    - In the `shutdown()` function, before closing Socket.IO, add:
      ```
      stopOutboxProcessor(outboxHandle);
      logger.info('Webhook outbox processor stopped');
      ```
    - The outbox processor will only attempt HTTP dispatch if `env.N8N_WEBHOOK_BASE_URL` is set. In dev without n8n, events accumulate in the outbox but no HTTP calls are made.

    Note: `createNotificationFromInternal` and `CreateNotificationInput` are already defined in notification.service.ts by Plan 05-02 Task 1. No changes to notification.service.ts needed here.
  </action>
  <verify>
    Run `cd server && npx tsc --noEmit` -- TypeScript compiles. Verify server.ts imports and calls `startOutboxProcessor`. Verify server.ts shutdown calls `stopOutboxProcessor`.
  </verify>
  <done>
    Outbox processor starts automatically on server boot (10-second polling interval) and stops cleanly during graceful shutdown. Events accumulate safely in dev without n8n running.
  </done>
</task>

</tasks>

<verification>
1. `cd server && npx tsc --noEmit` passes with zero errors
2. All 8 mutation paths call `enqueueWebhookEvent` (grep confirms 8 occurrences across 3 files)
3. `createNotification` is called for: status transitions (creator + assignee), assignments (assignee), comments (request creator)
4. server.ts starts outbox processor after Socket.IO init and stops it during shutdown
5. All webhook/notification calls are fire-and-forget (never break HTTP responses)
</verification>

<success_criteria>
- Every mutation fires a webhook event to the outbox
- Relevant users receive in-app notifications for status changes, assignments, and comments
- Outbox processor runs on server boot and dispatches pending events to n8n
- Fire-and-forget pattern maintained throughout -- no mutation latency increase
- Clean shutdown stops the outbox processor
</success_criteria>

<output>
After completion, create `.planning/phases/05-n8n-integration-notifications/05-03-SUMMARY.md`
</output>
