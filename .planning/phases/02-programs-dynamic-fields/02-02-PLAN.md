---
phase: 02-programs-dynamic-fields
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - server/src/middleware/authorizeProgram.ts
  - server/src/modules/program/program.service.ts
  - server/src/modules/program/program.controller.ts
  - server/src/modules/program/program.routes.ts
  - server/src/modules/program/program.schema.ts
  - server/src/modules/user/programMember.model.ts
  - server/src/shared/types.ts
autonomous: true
requirements:
  - PROG-03
  - PROG-06

must_haves:
  truths:
    - "Admin/manager can add members to a program with specific program-level roles (manager, team_member, client)"
    - "Admin/manager can remove members from a program"
    - "Admin/manager can list members of a program"
    - "Non-admin users see ONLY programs they are members of when listing programs -- no leakage of program names or data"
    - "Admin users see ALL programs when listing programs"
    - "Program timeframe boundaries are enforced -- submission-related actions are blocked outside active timeframes"
    - "The allowClientSubmission setting is available for downstream enforcement in Phase 3"
  artifacts:
    - path: "server/src/middleware/authorizeProgram.ts"
      provides: "Program-scoped authorization middleware checking ProgramMember membership"
      exports: ["authorizeProgram"]
    - path: "server/src/modules/program/program.service.ts"
      provides: "Updated service with access-scoped listing and member management"
      exports: ["getAccessiblePrograms", "addMember", "removeMember", "getMembers"]
    - path: "server/src/modules/program/program.routes.ts"
      provides: "Updated routes with member management endpoints and authorizeProgram middleware"
  key_links:
    - from: "server/src/middleware/authorizeProgram.ts"
      to: "server/src/modules/user/programMember.model.ts"
      via: "ProgramMember.findOne query"
      pattern: "ProgramMember\\.findOne"
    - from: "server/src/modules/program/program.service.ts"
      to: "server/src/modules/user/programMember.model.ts"
      via: "ProgramMember queries for member CRUD and access filtering"
      pattern: "ProgramMember\\.(find|create|deleteOne)"
    - from: "server/src/modules/program/program.routes.ts"
      to: "server/src/middleware/authorizeProgram.ts"
      via: "middleware applied on program-specific routes"
      pattern: "authorizeProgram"
---

<objective>
Add program-scoped authorization middleware, member management endpoints, and access-boundary enforcement so that users only see programs they belong to and program boundaries (timeframes, settings) are enforced.

Purpose: This plan implements the access control layer that prevents data leakage across program boundaries -- the critical security requirement for multi-program isolation. Without this, all programs are visible to all authenticated users.
Output: authorizeProgram middleware, program member CRUD, access-scoped program listing, timeframe enforcement.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
@.planning/phases/02-programs-dynamic-fields/02-01-SUMMARY.md

Key existing infrastructure:
- ProgramMember model already exists at server/src/modules/user/programMember.model.ts with userId+programId compound unique index, program-level roles (manager, team_member, client), isActive flag
- authenticate middleware at server/src/middleware/authenticate.ts
- authorize (role-based) middleware at server/src/middleware/authorize.ts
- Program model (created in Plan 01) at server/src/modules/program/program.model.ts
- Shared types with Role type at server/src/shared/types.ts
- ARCHITECTURE.md Pattern 3 describes the authorizeProgram pattern: admin bypasses, others require ProgramMember lookup
- PITFALLS.md Pitfall 4: centralized permission module, no inline role checks
- PITFALLS.md Pitfall 6: client data leakage through populate/aggregation -- query scoping at service layer
</context>

<tasks>

<task type="auto">
  <name>Task 1: authorizeProgram middleware and program member management</name>
  <files>
    server/src/middleware/authorizeProgram.ts
    server/src/modules/program/program.schema.ts
    server/src/modules/program/program.service.ts
    server/src/modules/program/program.controller.ts
    server/src/modules/user/programMember.model.ts
    server/src/shared/types.ts
  </files>
  <action>
**Create `server/src/middleware/authorizeProgram.ts`:**

Implement program-scoped authorization per ARCHITECTURE.md Pattern 3 and PITFALLS.md Pitfall 4 (centralized, not inline).

```typescript
// Middleware that checks if the authenticated user has access to a specific program.
// Admin role ALWAYS bypasses (implicit access to all programs).
// For other roles, checks ProgramMember collection for active membership.
// Optionally checks for a specific program-level role.
```

1. Export `authorizeProgram(options?: { roles?: ProgramRole[] })` factory function:
   - Extract `programId` from `req.params.programId` (standard location)
   - If `programId` is missing or not a valid ObjectId, throw `ValidationError('Invalid program ID')`
   - If `req.user.role === 'admin'`, call `next()` immediately (admin bypasses all program checks)
   - Otherwise, query `ProgramMember.findOne({ userId: req.user._id, programId, isActive: true }).lean()`
   - If no membership found, throw `ForbiddenError('No access to this program')`
   - If `options.roles` is provided, check that `membership.role` is in the allowed roles array. If not, throw `ForbiddenError('Insufficient program permissions')`
   - Attach `req.programMembership` to the request for downstream use (type it properly)
   - Call `next()`

2. Add to `server/src/shared/types.ts`:
   - Import ProgramRole type or re-export it
   - Add to Express Request augmentation: `programMembership?: { userId: string; programId: string; role: ProgramRole; }`

**Update `server/src/modules/user/programMember.model.ts`:**
   - Add `ref: 'Program'` to the `programId` field (the Program model now exists from Plan 01, so the reference is valid)

**Add member management schemas to `server/src/modules/program/program.schema.ts`:**

1. **`addMemberSchema`**: Zod object for POST /programs/:programId/members:
   - `userId`: z.string().regex(/^[0-9a-fA-F]{24}$/, 'Invalid user ID')
   - `role`: z.enum(['manager', 'team_member', 'client'])

2. **`listMembersQuerySchema`**: Query params for GET /programs/:programId/members:
   - `page`: z.coerce.number().int().min(1).default(1)
   - `limit`: z.coerce.number().int().min(1).max(100).default(20)
   - `role`: z.enum(['manager', 'team_member', 'client']).optional()

Export types: AddMemberInput, ListMembersQuery.

**Add member management to `server/src/modules/program/program.service.ts`:**

1. **`addMember(programId: string, data: AddMemberInput, addedBy: string)`**:
   - Verify program exists and is active (not archived)
   - Verify user exists and is active: `User.findById(data.userId)`
   - Create ProgramMember (handle duplicate with 409 like user.service.ts assignToProgram)
   - Invalidate member cache: `cacheInvalidate('programs:${programId}:members:*')`
   - Return membership

2. **`removeMember(programId: string, memberId: string)`**:
   - Delete ProgramMember by _id and programId (both must match)
   - If not found, throw NotFoundError
   - Invalidate member cache

3. **`getMembers(programId: string, query: ListMembersQuery)`**:
   - Build filter: `{ programId, isActive: true }`, optional role filter
   - Populate userId with `select: 'firstName lastName email role'` (PITFALLS.md Pitfall 6: never populate full user document)
   - Paginate, return `{ members, total, page, limit }`

**Add member controllers to `server/src/modules/program/program.controller.ts`:**

1. `addMember` -- POST, 201, `{ membership }`
2. `removeMember` -- DELETE, 204
3. `getMembers` -- GET, 200, paginatedResponse
  </action>
  <verify>
    Run `npx tsc --noEmit` from server/ directory -- should compile clean.
    Verify authorizeProgram.ts exists and exports the middleware factory.
    Verify types.ts includes programMembership on Express Request.
    Verify programMember.model.ts has ref: 'Program' on programId.
  </verify>
  <done>
    authorizeProgram middleware exists and checks ProgramMember for non-admin users.
    Admin users bypass all program-level checks.
    Program member management (add, remove, list) works via service layer.
    Member listing populates only safe user fields (no password, no full document).
    ProgramMember model now references the Program model.
    Express Request type augmented with programMembership.
    TypeScript compiles with no errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Access-scoped program listing and boundary enforcement</name>
  <files>
    server/src/modules/program/program.service.ts
    server/src/modules/program/program.controller.ts
    server/src/modules/program/program.routes.ts
  </files>
  <action>
**Update `server/src/modules/program/program.service.ts`:**

1. **Modify `getPrograms` to be access-scoped (PROG-06 -- users see only their programs):**
   - Add a `userId` parameter and a `userRole` parameter (from req.user)
   - If `userRole === 'admin'`, return all programs (no access filter)
   - If `userRole === 'manager'`, find all programIds where user has an active membership as manager, PLUS all programs they created. Filter programs to those IDs.
   - For `team_member` and `client` roles: find all programIds where user has an active membership. Filter programs to those IDs only.
   - Implementation: query `ProgramMember.find({ userId, isActive: true }).select('programId').lean()` to get allowed program IDs, then add `{ _id: { $in: allowedProgramIds } }` to the filter.
   - Cache key should include userId for non-admin users: `programs:list:${userId}:${JSON.stringify(query)}`

2. **Add `checkProgramTimeframe(programId: string)` helper:**
   - Fetch program (use getProgramById which handles caching)
   - If program status is 'archived', throw `AppError('Program is archived and not accepting submissions', 400)`
   - If `timeframes.startDate` exists and is in the future, throw `AppError('Program has not started accepting submissions yet', 400)`
   - If `timeframes.endDate` exists and is in the past, throw `AppError('Program submission period has ended', 400)`
   - Export this function -- it will be called by Phase 3 (Request module) before creating/submitting requests. For now, it just exists as a reusable utility.

**Update `server/src/modules/program/program.controller.ts`:**

1. **Modify `getPrograms` controller** to pass `req.user!._id` and `req.user!.role` to the service's getPrograms function.

**Update `server/src/modules/program/program.routes.ts` to add member management routes and apply authorizeProgram:**

Restructure routes to have two layers of authorization:

1. **Public program routes** (authenticated + admin/manager for management, authenticated for listing):
   - `POST /` -- authenticate, authorize('admin', 'manager'), validate(createProgramSchema) --> createProgram
   - `GET /` -- authenticate --> getPrograms (access-scoped in service layer based on user role/memberships)

2. **Program-specific routes** (authenticated + authorizeProgram for access check):
   - `GET /:programId` -- authenticate, authorizeProgram() --> getProgramById
   - `PATCH /:programId` -- authenticate, authorize('admin', 'manager'), authorizeProgram({ roles: ['manager'] }) --> updateProgram
   - `PATCH /:programId/archive` -- authenticate, authorize('admin', 'manager'), authorizeProgram({ roles: ['manager'] }) --> archiveProgram

3. **Member management routes** (nested under /:programId/members, admin/manager only):
   - `GET /:programId/members` -- authenticate, authorize('admin', 'manager'), authorizeProgram({ roles: ['manager'] }), validate(listMembersQuerySchema, 'query'), paginate() --> getMembers
   - `POST /:programId/members` -- authenticate, authorize('admin', 'manager'), authorizeProgram({ roles: ['manager'] }), validate(addMemberSchema) --> addMember
   - `DELETE /:programId/members/:memberId` -- authenticate, authorize('admin', 'manager'), authorizeProgram({ roles: ['manager'] }) --> removeMember

**IMPORTANT route restructuring note:** The Plan 01 routes used `router.use(authenticate)` and `router.use(authorize('admin', 'manager'))` at the router level. That must be REMOVED because now GET / (list programs) needs to be accessible by all authenticated users (not just admin/manager), and GET /:programId needs authorizeProgram (not just role check). Apply middleware per-route or per-route-group instead.

Import authorizeProgram from `../../middleware/authorizeProgram.js`.
Import addMemberSchema, listMembersQuerySchema from `./program.schema.js`.
  </action>
  <verify>
    Run `npx tsc --noEmit` from server/ directory -- should compile clean.
    Verify GET /api/v1/programs does NOT have authorize('admin', 'manager') middleware (all authenticated users can list).
    Verify GET /:programId has authorizeProgram() middleware.
    Verify member management routes exist under /:programId/members.
    Verify getPrograms service function accepts userId and userRole parameters.
    Verify checkProgramTimeframe function exists and is exported.
  </verify>
  <done>
    Non-admin users see ONLY programs they are members of when calling GET /api/v1/programs (PROG-06 enforced).
    Admin users see all programs.
    authorizeProgram middleware protects all program-specific routes (GET /:programId, PATCH, archive).
    Program member management endpoints work: add member, remove member, list members.
    checkProgramTimeframe utility is available for Phase 3 to enforce submission boundaries.
    Route structure reflects proper authorization layering: authenticate on all, authorize for role gates, authorizeProgram for program-specific access.
    TypeScript compiles with no errors.
  </done>
</task>

</tasks>

<verification>
1. `cd server && npx tsc --noEmit` passes with zero errors
2. All files exist and are properly modified:
   - server/src/middleware/authorizeProgram.ts (created)
   - server/src/modules/program/program.service.ts (modified)
   - server/src/modules/program/program.controller.ts (modified)
   - server/src/modules/program/program.routes.ts (modified)
   - server/src/modules/program/program.schema.ts (modified)
   - server/src/modules/user/programMember.model.ts (modified)
   - server/src/shared/types.ts (modified)
3. authorizeProgram middleware checks ProgramMember for non-admin access
4. GET /api/v1/programs returns only accessible programs for non-admin users
5. Member management CRUD endpoints exist under /:programId/members
6. checkProgramTimeframe exists for Phase 3 consumption
</verification>

<success_criteria>
- Non-admin users see only their programs in list view (no program name leakage)
- Admin users see all programs
- authorizeProgram blocks access to programs the user is not a member of
- Members can be added to and removed from programs
- Member listing populates only safe user fields
- Program timeframe boundary checking utility exists
- TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/02-programs-dynamic-fields/02-02-SUMMARY.md`
</output>
