---
phase: 09-due-dates-reminders
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/modules/program/program.model.ts
  - server/src/modules/program/program.schema.ts
  - server/src/modules/request/request.model.ts
  - server/src/modules/request/request.schema.ts
  - server/src/modules/request/request.service.ts
  - server/src/modules/internal/internal.controller.ts
  - client/src/lib/types.ts
autonomous: true
requirements:
  - DUE-01
  - DUE-02
  - DUE-04

must_haves:
  truths:
    - "Admin/manager can configure due date rules (defaultOffsetDays, field-level dueDateField) on a program via PATCH /programs/:programId"
    - "When a request is created, a dueDate is computed from program rules and stored on the request document"
    - "Requests returned from list and detail APIs include the dueDate field"
    - "The pending-reminders internal API returns requests based on actual dueDate (upcoming within 24h, overdue) rather than 48h staleness"
    - "sortBy=dueDate works on the list requests endpoint"
  artifacts:
    - path: "server/src/modules/program/program.model.ts"
      provides: "dueDateConfig embedded subdocument on Program (defaultOffsetDays, dueDateField)"
      contains: "dueDateConfig"
    - path: "server/src/modules/request/request.model.ts"
      provides: "dueDate field on Request schema"
      contains: "dueDate"
    - path: "server/src/modules/request/request.service.ts"
      provides: "Due date computation in createRequest, dueDate sort support"
      contains: "computeDueDate"
    - path: "server/src/modules/internal/internal.controller.ts"
      provides: "Updated getPendingReminders using dueDate for overdue/upcoming checks"
      contains: "dueDate"
    - path: "client/src/lib/types.ts"
      provides: "Updated TypeScript interfaces with dueDate and dueDateConfig types"
      contains: "dueDate"
  key_links:
    - from: "server/src/modules/request/request.service.ts"
      to: "server/src/modules/program/program.model.ts"
      via: "getProgramById to read dueDateConfig for computation"
      pattern: "program\\.dueDateConfig"
    - from: "server/src/modules/internal/internal.controller.ts"
      to: "server/src/modules/request/request.model.ts"
      via: "Query on dueDate field for reminder lookup"
      pattern: "dueDate.*\\$lt|\\$lte"
---

<objective>
Add due date configuration to programs and due date computation/storage to requests. Update the backend to compute due dates at request creation, include dueDate in all API responses, support dueDate sorting, and upgrade the pending-reminders internal API to use actual due dates.

Purpose: This is the data-layer foundation for all due date features -- without stored dueDate on requests and dueDateConfig on programs, neither the frontend indicators nor the n8n reminder workflow can function.
Output: Program model with dueDateConfig, Request model with dueDate, computed due dates on creation, updated pending-reminders API.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@server/src/modules/program/program.model.ts
@server/src/modules/program/program.schema.ts
@server/src/modules/request/request.model.ts
@server/src/modules/request/request.schema.ts
@server/src/modules/request/request.service.ts
@server/src/modules/internal/internal.controller.ts
@client/src/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Program dueDateConfig + Request dueDate model/schema/computation</name>
  <files>
    server/src/modules/program/program.model.ts
    server/src/modules/program/program.schema.ts
    server/src/modules/request/request.model.ts
    server/src/modules/request/request.schema.ts
    server/src/modules/request/request.service.ts
    client/src/lib/types.ts
  </files>
  <action>
    1. **Program model** (`program.model.ts`): Add `dueDateConfig` embedded subdocument to IProgramDocument and programSchema:
       ```typescript
       dueDateConfig: {
         enabled: boolean;          // default false
         defaultOffsetDays: number;  // default 30 — days from creation to due date
         dueDateField?: string;      // optional — key of a 'date' type field definition whose value overrides the default offset
       }
       ```
       Add the interface `IDueDateConfig { enabled: boolean; defaultOffsetDays: number; dueDateField?: string; }` and include it in IProgramDocument. Schema defaults: `{ enabled: { type: Boolean, default: false }, defaultOffsetDays: { type: Number, default: 30 }, dueDateField: { type: String, default: undefined } }`.

    2. **Program schema** (`program.schema.ts`): Add `dueDateConfig` to both createProgramSchema and updateProgramSchema Zod objects:
       ```typescript
       dueDateConfig: z.object({
         enabled: z.boolean().default(false),
         defaultOffsetDays: z.number().int().min(1).max(365).default(30),
         dueDateField: z.string().regex(/^[a-z][a-z0-9_]*$/).optional(),
       }).default({})
       ```
       For updateProgramSchema, make dueDateConfig optional (`.optional()`). Add a `.refine()` on createProgramSchema that validates: if `dueDateConfig.dueDateField` is set, it must reference a key present in `fieldDefinitions` with `type: 'date'`. Same refinement for updateProgramSchema when both fields are provided.

    3. **Request model** (`request.model.ts`): Add `dueDate` optional Date field to IRequestDocument and requestSchema:
       ```typescript
       dueDate: { type: Date, default: undefined, index: true }
       ```
       Add compound index `{ programId: 1, dueDate: 1 }` for calendar/reminder queries.

    4. **Request schema** (`request.schema.ts`): Add `dueDate` to `listRequestsQuerySchema.sortBy` enum — extend the existing `.enum([...])` to include `'dueDate'`. Also add `dueBefore` and `dueAfter` optional coerce date filters to `listRequestsQuerySchema` for calendar-range queries.

    5. **Request service** (`request.service.ts`):
       - Add a `computeDueDate` helper function:
         ```typescript
         function computeDueDate(program: IProgramDocument, fields?: Record<string, unknown>): Date | undefined {
           if (!program.dueDateConfig?.enabled) return undefined;
           // If dueDateField is set and a date value exists in fields, use it
           if (program.dueDateConfig.dueDateField && fields) {
             const fieldValue = fields[program.dueDateConfig.dueDateField];
             if (fieldValue && typeof fieldValue === 'string') {
               const parsed = new Date(fieldValue);
               if (!isNaN(parsed.getTime())) return parsed;
             }
           }
           // Fall back to defaultOffsetDays from now
           const offset = program.dueDateConfig.defaultOffsetDays ?? 30;
           return new Date(Date.now() + offset * 24 * 60 * 60 * 1000);
         }
         ```
       - In `createRequest`: after `validateFields`, call `computeDueDate(program, data.fields)` and pass the result as `dueDate` to `Request.create()`.
       - In `getRequests`: add support for `dueBefore`/`dueAfter` query filters (same pattern as createdAfter/createdBefore but on dueDate field). Ensure `sortBy: 'dueDate'` works in the dynamic sort block.

    6. **Client types** (`client/src/lib/types.ts`):
       - Add `dueDate?: string;` to `RequestItem` interface.
       - Add `dueDateConfig?: { enabled: boolean; defaultOffsetDays: number; dueDateField?: string; }` to `Program` interface.
  </action>
  <verify>
    Run `cd server && npx tsc --noEmit` to confirm no TypeScript errors. Verify the program model, request model, and service compile cleanly. Check that the request schema accepts dueDate as a sortBy value and dueBefore/dueAfter as query params.
  </verify>
  <done>
    Program model has dueDateConfig subdocument. Request model has indexed dueDate field. createRequest computes and stores dueDate from program rules. getRequests supports dueDate sort and dueBefore/dueAfter filters. Client types updated with dueDate on RequestItem and dueDateConfig on Program.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update pending-reminders API for due-date-based lookups</name>
  <files>
    server/src/modules/internal/internal.controller.ts
  </files>
  <action>
    Rewrite the `getPendingReminders` controller in `internal.controller.ts` to use actual `dueDate` field instead of the 48-hour staleness heuristic:

    1. Accept new query params: `?type=upcoming|overdue` (default: both), `?programId=...` (optional filter).
    2. **Overdue query**: `{ dueDate: { $lt: new Date() }, status: { $in: ['submitted', 'in_review'] } }` — requests past their due date that are still pending action.
    3. **Upcoming query**: `{ dueDate: { $gte: new Date(), $lte: new Date(Date.now() + 24 * 60 * 60 * 1000) }, status: { $in: ['submitted', 'in_review', 'draft'] } }` — requests due within the next 24 hours.
    4. When `type` is not specified, combine both queries with `$or`.
    5. Keep the existing response shape: `{ reminders: [...], count }`. Each reminder object should now include `dueDate` and `daysOverdue` (negative = days until due) in the response for n8n to use in email templates:
       ```typescript
       {
         requestId, title, programId, status,
         dueDate: r.dueDate?.toISOString(),
         daysOverdue: Math.floor((Date.now() - (r.dueDate?.getTime() ?? Date.now())) / (24*60*60*1000)),
         assignedTo: { email, name },
         createdBy: { email, name },
       }
       ```
    6. Keep `.populate('createdBy', ...)`, `.populate('assignedTo', ...)`, `.sort({ dueDate: 1 })`, `.limit(100)`.
    7. Add `dueDate` to the `filter` query to skip requests without a dueDate: `{ dueDate: { $exists: true, $ne: null } }` merged with the type-specific filters.
  </action>
  <verify>
    Run `cd server && npx tsc --noEmit` to confirm no TypeScript errors. Confirm the controller compiles and the response shape includes dueDate and daysOverdue fields.
  </verify>
  <done>
    Pending-reminders internal API now queries on actual dueDate field. Returns overdue requests (past due date, still pending) and upcoming requests (due within 24h). Response includes dueDate and daysOverdue for n8n email templates. Old 48h staleness logic replaced.
  </done>
</task>

</tasks>

<verification>
- `cd server && npx tsc --noEmit` compiles without errors
- Program model exports IDueDateConfig and includes dueDateConfig in IProgramDocument
- Request model has dueDate: Date with index
- createRequest computes dueDate from program dueDateConfig
- listRequestsQuerySchema accepts sortBy='dueDate', dueBefore, dueAfter
- getPendingReminders uses dueDate for overdue/upcoming logic
- client/src/lib/types.ts has dueDate on RequestItem and dueDateConfig on Program
</verification>

<success_criteria>
Backend data model supports due date configuration per program and due date storage per request. Due dates are computed at creation time. The API supports sorting and filtering by due date. The internal reminder API uses actual due dates for n8n lookups.
</success_criteria>

<output>
After completion, create `.planning/phases/09-due-dates-reminders/09-01-SUMMARY.md`
</output>
