---
phase: 04-real-time-events
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - server/src/modules/request/request.service.ts
  - server/src/modules/request/comment.service.ts
  - server/src/modules/request/attachment.service.ts
autonomous: true
requirements: [RT-02]

must_haves:
  truths:
    - "When a request is created, all connected users in that program's room receive a request:created event in real-time"
    - "When a request is updated, transitioned, or assigned, all connected users in that program's room receive the corresponding event in real-time"
    - "When a comment is added or deleted, all connected users in that program's room receive the corresponding event in real-time"
    - "When an attachment is uploaded or deleted, all connected users in that program's room receive the corresponding event in real-time"
    - "Socket emission is fire-and-forget -- failures never break the main HTTP response"
  artifacts:
    - path: "server/src/modules/request/request.service.ts"
      provides: "emitToProgram calls after createRequest, updateRequest, transitionRequest, assignRequest"
      contains: "emitToProgram"
    - path: "server/src/modules/request/comment.service.ts"
      provides: "emitToProgram calls after addComment and deleteComment"
      contains: "emitToProgram"
    - path: "server/src/modules/request/attachment.service.ts"
      provides: "emitToProgram calls after uploadAttachment and deleteAttachment"
      contains: "emitToProgram"
  key_links:
    - from: "server/src/modules/request/request.service.ts"
      to: "server/src/shared/socketEvents.ts"
      via: "import emitToProgram and SocketEventPayload"
      pattern: "import.*emitToProgram.*socketEvents"
    - from: "server/src/modules/request/comment.service.ts"
      to: "server/src/shared/socketEvents.ts"
      via: "import emitToProgram and SocketEventPayload"
      pattern: "import.*emitToProgram.*socketEvents"
    - from: "server/src/modules/request/attachment.service.ts"
      to: "server/src/shared/socketEvents.ts"
      via: "import emitToProgram and SocketEventPayload"
      pattern: "import.*emitToProgram.*socketEvents"
    - from: "server/src/modules/request/request.service.ts"
      to: "server/src/config/socket.ts"
      via: "emitToProgram re-exported from socketEvents or imported from config/socket"
      pattern: "emitToProgram"
---

<objective>
Wire real-time event emission into all request, comment, and attachment mutation service functions.

Purpose: Every mutation (create, update, transition, assign, comment, attachment) must broadcast to the relevant program's Socket.IO room so connected clients see updates instantly without polling.

Output: All 8 mutation paths emit typed Socket.IO events to the correct program room, fire-and-forget style.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-real-time-events/04-01-SUMMARY.md
@server/src/shared/socketEvents.ts
@server/src/config/socket.ts
@server/src/modules/request/request.service.ts
@server/src/modules/request/comment.service.ts
@server/src/modules/request/attachment.service.ts
@server/src/modules/auth/auth.model.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Socket.IO emission into request mutation services</name>
  <files>server/src/modules/request/request.service.ts</files>
  <action>
    1. Add import at the top of `request.service.ts`:
       ```typescript
       import { emitToProgram } from '../../config/socket.js';
       import type { SocketEventPayload } from '../../shared/socketEvents.js';
       ```

    2. Also import `User` model to look up performer name for the event payload:
       ```typescript
       import { User } from '../auth/auth.model.js';
       ```

    3. Create a helper function at the top of the file (after imports) to build performer info. This avoids repeated User lookups since the user is already authenticated:
       ```typescript
       async function getPerformerName(userId: string): Promise<{ userId: string; name: string }> {
         const user = await User.findById(userId).select('firstName lastName').lean();
         return {
           userId,
           name: user ? `${user.firstName} ${user.lastName}` : 'Unknown User',
         };
       }
       ```

    4. In `createRequest()`, AFTER the audit log entry and cache invalidation (at the end, before `return request`), add:
       ```typescript
       // Emit real-time event (fire-and-forget)
       getPerformerName(userId).then((performer) => {
         emitToProgram(data.programId, 'request:created', {
           event: 'request:created',
           programId: data.programId,
           requestId: request._id.toString(),
           data: { request: request.toObject() },
           performedBy: performer,
           timestamp: new Date().toISOString(),
         });
       }).catch(() => {});
       ```
       IMPORTANT: Use `.then().catch()` pattern (not await) so the emission is truly fire-and-forget and never delays the HTTP response or throws.

    5. In `updateRequest()`, AFTER cache invalidation (before `return updated`), add:
       ```typescript
       // Emit real-time event (fire-and-forget)
       getPerformerName(userId).then((performer) => {
         emitToProgram(request.programId.toString(), 'request:updated', {
           event: 'request:updated',
           programId: request.programId.toString(),
           requestId: requestId,
           data: { request: updated.toObject(), changedFields: Object.keys(data) },
           performedBy: performer,
           timestamp: new Date().toISOString(),
         });
       }).catch(() => {});
       ```

    6. In `transitionRequest()`, AFTER cache invalidation (before `return updated`), add:
       ```typescript
       // Emit real-time event (fire-and-forget)
       getPerformerName(userId).then((performer) => {
         emitToProgram(request.programId.toString(), 'request:status_changed', {
           event: 'request:status_changed',
           programId: request.programId.toString(),
           requestId: requestId,
           data: { request: updated.toObject(), from: beforeStatus, to: targetStatus },
           performedBy: performer,
           timestamp: new Date().toISOString(),
         });
       }).catch(() => {});
       ```

    7. In `assignRequest()`, AFTER cache invalidation (before `return updated`), add:
       ```typescript
       // Emit real-time event (fire-and-forget)
       getPerformerName(performedByUserId).then((performer) => {
         emitToProgram(request.programId.toString(), 'request:assigned', {
           event: 'request:assigned',
           programId: request.programId.toString(),
           requestId: requestId,
           data: { request: updated.toObject(), assignedTo: assignedToUserId, previousAssignee: beforeAssignee },
           performedBy: performer,
           timestamp: new Date().toISOString(),
         });
       }).catch(() => {});
       ```
  </action>
  <verify>
    Run `cd server && npx tsc --noEmit` and confirm no type errors. Grep for `emitToProgram` in request.service.ts and verify 4 occurrences (one per mutation function).
  </verify>
  <done>
    All 4 request mutation functions (create, update, transition, assign) emit typed Socket.IO events to the correct program room. Emissions are fire-and-forget and never block or throw.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Socket.IO emission into comment and attachment services</name>
  <files>server/src/modules/request/comment.service.ts, server/src/modules/request/attachment.service.ts</files>
  <action>
    1. **comment.service.ts** -- Add imports:
       ```typescript
       import { emitToProgram } from '../../config/socket.js';
       import type { SocketEventPayload } from '../../shared/socketEvents.js';
       import { User } from '../auth/auth.model.js';
       ```

    2. Add the same `getPerformerName` helper (or import from a shared location -- but to keep it simple and avoid circular imports, duplicate the 4-line helper in each service file):
       ```typescript
       async function getPerformerName(userId: string): Promise<{ userId: string; name: string }> {
         const user = await User.findById(userId).select('firstName lastName').lean();
         return {
           userId,
           name: user ? `${user.firstName} ${user.lastName}` : 'Unknown User',
         };
       }
       ```

    3. In `addComment()`, AFTER the audit log entry (before `return populated`), add:
       ```typescript
       // Emit real-time event (fire-and-forget)
       getPerformerName(authorId).then((performer) => {
         emitToProgram(programId, 'comment:added', {
           event: 'comment:added',
           programId,
           requestId,
           data: { comment: populated },
           performedBy: performer,
           timestamp: new Date().toISOString(),
         });
       }).catch(() => {});
       ```

    4. In `deleteComment()`, AFTER the audit log entry (at the end of the function), add:
       ```typescript
       // Emit real-time event (fire-and-forget)
       getPerformerName(userId).then((performer) => {
         emitToProgram(programId, 'comment:deleted', {
           event: 'comment:deleted',
           programId,
           requestId,
           data: { commentId },
           performedBy: performer,
           timestamp: new Date().toISOString(),
         });
       }).catch(() => {});
       ```

    5. **attachment.service.ts** -- Add imports (after existing imports):
       ```typescript
       import { emitToProgram } from '../../config/socket.js';
       import type { SocketEventPayload } from '../../shared/socketEvents.js';
       import { User } from '../auth/auth.model.js';
       ```

    6. Add the same `getPerformerName` helper.

    7. In `uploadAttachment()`, AFTER the audit log entry (before `return attachment`), add:
       ```typescript
       // Emit real-time event (fire-and-forget)
       getPerformerName(uploadedBy).then((performer) => {
         emitToProgram(programId, 'attachment:uploaded', {
           event: 'attachment:uploaded',
           programId,
           requestId,
           data: { attachment: attachment.toObject() },
           performedBy: performer,
           timestamp: new Date().toISOString(),
         });
       }).catch(() => {});
       ```

    8. In `deleteAttachment()`, AFTER the audit log entry (at the end of the function), add:
       ```typescript
       // Emit real-time event (fire-and-forget)
       getPerformerName(userId).then((performer) => {
         emitToProgram(programId, 'attachment:deleted', {
           event: 'attachment:deleted',
           programId,
           requestId,
           data: { attachmentId },
           performedBy: performer,
           timestamp: new Date().toISOString(),
         });
       }).catch(() => {});
       ```
  </action>
  <verify>
    Run `cd server && npx tsc --noEmit` and confirm no type errors. Grep for `emitToProgram` in comment.service.ts (2 occurrences) and attachment.service.ts (2 occurrences).
  </verify>
  <done>
    All 4 comment/attachment mutation functions (addComment, deleteComment, uploadAttachment, deleteAttachment) emit typed Socket.IO events to the correct program room. Combined with Task 1, all 8 mutation paths now broadcast real-time events.
  </done>
</task>

</tasks>

<verification>
1. `cd server && npx tsc --noEmit` passes with no errors
2. `emitToProgram` is called in all 8 mutation functions:
   - request.service.ts: createRequest, updateRequest, transitionRequest, assignRequest (4 calls)
   - comment.service.ts: addComment, deleteComment (2 calls)
   - attachment.service.ts: uploadAttachment, deleteAttachment (2 calls)
3. All emissions use `.then().catch(() => {})` pattern (fire-and-forget, never blocking HTTP response)
4. Each emission includes: event name, programId, requestId, mutation-specific data, performedBy with name, ISO timestamp
5. Event names match the typed catalog in socketEvents.ts
</verification>

<success_criteria>
- Every request mutation broadcasts a typed event to the relevant program's Socket.IO room
- Every comment mutation broadcasts a typed event to the relevant program's Socket.IO room
- Every attachment mutation broadcasts a typed event to the relevant program's Socket.IO room
- Socket emission is fire-and-forget -- failures never break the main HTTP response or throw errors
- TypeScript strict mode passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-real-time-events/04-02-SUMMARY.md`
</output>
