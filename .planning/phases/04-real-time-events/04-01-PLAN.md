---
phase: 04-real-time-events
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/config/socket.ts
  - server/src/shared/socketEvents.ts
  - server/src/server.ts
  - server/package.json
autonomous: true
requirements: [RT-01, RT-03, RT-04]

must_haves:
  truths:
    - "Socket.IO connection without a valid JWT is rejected with an authentication error"
    - "Authenticated user is automatically joined to Socket.IO rooms matching their program memberships"
    - "If a user's connection drops and they reconnect with a valid JWT, they rejoin their program rooms and receive a catch-up snapshot of recent events they may have missed"
    - "Socket.IO rooms are scoped per programId -- events emitted to a room are only received by members of that program"
  artifacts:
    - path: "server/src/config/socket.ts"
      provides: "Socket.IO server initialization, JWT auth middleware, room join/leave logic, reconnection handler, emitToProgram utility"
      min_lines: 80
    - path: "server/src/shared/socketEvents.ts"
      provides: "Typed event catalog with event names, payload interfaces, and emitToProgram helper"
      min_lines: 40
    - path: "server/src/server.ts"
      provides: "Updated server entry point that passes http.Server to Socket.IO init and exports io"
  key_links:
    - from: "server/src/config/socket.ts"
      to: "server/src/config/env.ts"
      via: "JWT_ACCESS_SECRET for token verification"
      pattern: "env\\.JWT_ACCESS_SECRET"
    - from: "server/src/config/socket.ts"
      to: "server/src/modules/user/programMember.model.ts"
      via: "ProgramMember.find to look up user program memberships for room assignment"
      pattern: "ProgramMember\\.find"
    - from: "server/src/server.ts"
      to: "server/src/config/socket.ts"
      via: "initSocketIO(server) call in startup sequence"
      pattern: "initSocketIO"
---

<objective>
Set up Socket.IO server with JWT authentication, program-scoped rooms, and reconnection catch-up.

Purpose: Provide the real-time transport layer that all mutation broadcasts (Plan 04-02) will use. Without this infrastructure, no real-time events can flow.

Output: Working Socket.IO server that authenticates connections via JWT, auto-joins users to their program rooms, and handles reconnection gracefully.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@server/src/server.ts
@server/src/config/env.ts
@server/src/config/passport.ts
@server/src/middleware/authenticate.ts
@server/src/shared/types.ts
@server/src/modules/user/programMember.model.ts
@server/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install socket.io and create typed event catalog</name>
  <files>server/package.json, server/src/shared/socketEvents.ts</files>
  <action>
    1. Install socket.io (server-side only -- client SDK is not needed on the Express server):
       ```bash
       cd server && npm install socket.io
       ```
       Note: socket.io v4 includes its own TypeScript types, no separate @types package needed.

    2. Create `server/src/shared/socketEvents.ts` -- the typed event catalog defining all real-time event names and their payloads. This file is the single source of truth for event shapes:

       - Define a `SocketEventName` union type with these event names:
         - `request:created` -- emitted when a new request is created
         - `request:updated` -- emitted when a draft request is edited
         - `request:status_changed` -- emitted when a request transitions state
         - `request:assigned` -- emitted when a request is assigned/reassigned
         - `comment:added` -- emitted when a comment is added to a request
         - `comment:deleted` -- emitted when a comment is deleted
         - `attachment:uploaded` -- emitted when a file is uploaded
         - `attachment:deleted` -- emitted when a file is deleted

       - Define `SocketEventPayload` interface with fields:
         - `event: SocketEventName` -- the event type
         - `programId: string` -- the program room this belongs to
         - `requestId: string` -- the affected request
         - `data: Record<string, unknown>` -- event-specific data (e.g., the request object, comment object)
         - `performedBy: { userId: string; name: string }` -- who triggered this
         - `timestamp: string` -- ISO date string

       - Define `ServerToClientEvents` interface mapping event names to their handler signatures (for Socket.IO typed events). Each event handler receives a `SocketEventPayload`.

       - Define `ClientToServerEvents` interface (empty for now -- clients don't push events to server in v1, only receive).

       - Define `InterServerEvents` interface (empty -- single-server deployment).

       - Define `SocketData` interface for per-socket custom data:
         - `userId: string`
         - `userRole: string`
         - `programs: string[]` -- list of programIds the user is a member of

       - Export a `RECENT_EVENTS_TTL` constant set to `300` (5 minutes in seconds) -- the Redis TTL for the per-room recent events list used for reconnection catch-up.

       - Export a `MAX_CATCHUP_EVENTS` constant set to `50` -- max events to send on reconnection.
  </action>
  <verify>
    Run `cd server && npx tsc --noEmit` and confirm no type errors. Verify `socket.io` is in package.json dependencies.
  </verify>
  <done>
    socket.io installed in server/package.json. socketEvents.ts exports typed event names, payload interfaces, and server/client event maps. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Socket.IO server with JWT auth, room management, and reconnection</name>
  <files>server/src/config/socket.ts, server/src/server.ts</files>
  <action>
    1. Create `server/src/config/socket.ts` with the following:

       **Imports:** `Server` from `socket.io`, `http` module, `jsonwebtoken` (verify), `env` from config, `ProgramMember` model, `User` model (from auth.model), `redis` client (from config/redis), `logger`, and all types from `socketEvents.ts`.

       **initSocketIO(httpServer: http.Server): Server** function:
       - Create a new Socket.IO `Server` instance attached to the httpServer with these options:
         - `cors: { origin: env.CLIENT_URL, credentials: true }` -- match Express CORS config
         - `pingTimeout: 60000` -- 60s ping timeout
         - `pingInterval: 25000` -- 25s ping interval
       - The Server should be typed with `ServerToClientEvents, ClientToServerEvents, InterServerEvents, SocketData`.

       **JWT Authentication Middleware** (`io.use()`):
       - Extract token from `socket.handshake.auth.token` (the standard Socket.IO auth field).
       - If no token, call `next(new Error('Authentication required'))`.
       - Verify the token using `jwt.verify(token, env.JWT_ACCESS_SECRET)` inside a try/catch.
       - On invalid/expired token, call `next(new Error('Invalid or expired token'))`.
       - Extract `sub` (userId) from the decoded payload.
       - Look up the user via `User.findById(sub).select('firstName lastName email role isActive')`.
       - If user not found or `isActive === false`, call `next(new Error('User not found or inactive'))`.
       - Attach user info to `socket.data`: `userId`, `userRole` (from user.role), and leave `programs` empty (filled next).
       - Call `next()` on success.

       **Connection Handler** (`io.on('connection', async (socket) => { ... })`):
       - Log connection: `logger.info(\`Socket connected: \${socket.id} (user: \${socket.data.userId})\`)`.
       - **Room Join:** Query `ProgramMember.find({ userId: socket.data.userId, isActive: true }).select('programId').lean()` to get all active program memberships. Map to string programIds. Store in `socket.data.programs`. For each programId, call `socket.join(\`program:\${programId}\`)`.
       - Log rooms joined: `logger.debug(\`User \${socket.data.userId} joined rooms: \${socket.data.programs.join(', ')}\`)`.

       - **Reconnection Catch-Up:** After joining rooms, check for a `lastEventTimestamp` in `socket.handshake.auth`. If present:
         - For each program in `socket.data.programs`, read the Redis key `socket:events:program:{programId}` (a sorted set, scored by timestamp).
         - Use `redis.zrangebyscore` to get events with score > `lastEventTimestamp` up to `MAX_CATCHUP_EVENTS`.
         - Parse each event from JSON and emit to the socket individually as the appropriate event name.
         - This allows clients that reconnect to "catch up" on events they may have missed during disconnection.

       - **Disconnect Handler:** `socket.on('disconnect', (reason) => { logger.info(\`Socket disconnected: \${socket.id} (reason: \${reason})\`); })`.

       **emitToProgram(programId: string, event: SocketEventName, payload: SocketEventPayload): void** exported function:
       - Get the io instance (stored in module scope after initSocketIO).
       - If io is not initialized, log a warning and return (fire-and-forget, like audit logging).
       - Emit to the program room: `io.to(\`program:\${programId}\`).emit(event, payload)`.
       - Also store the event in Redis for catch-up: Use `redis.zadd(\`socket:events:program:\${programId}\`, Date.now(), JSON.stringify(payload))` and set expiry `redis.expire(\`socket:events:program:\${programId}\`, RECENT_EVENTS_TTL)`.
       - After adding, trim old entries: `redis.zremrangebyscore(\`socket:events:program:\${programId}\`, '-inf', Date.now() - RECENT_EVENTS_TTL * 1000)` to prevent unbounded growth.

       **getIO(): Server** exported function (for tests/internal use):
       - Returns the io instance. Throws if not initialized.

    2. Update `server/src/server.ts`:
       - Import `{ initSocketIO }` from `./config/socket.js`.
       - After `const server = http.createServer(app);` and inside the `start()` function after Redis ping verification (step 4), add step 4.5:
         ```typescript
         // 4.5. Initialize Socket.IO
         initSocketIO(server);
         logger.info('Socket.IO initialized');
         ```
       - In the `shutdown()` function, add Socket.IO graceful close BEFORE http server close:
         ```typescript
         const { getIO } = await import('./config/socket.js');
         try {
           const io = getIO();
           io.close();
           logger.info('Socket.IO closed');
         } catch { /* not initialized */ }
         ```
  </action>
  <verify>
    Run `cd server && npx tsc --noEmit` and confirm no type errors. Verify the server starts cleanly with `cd server && timeout 5 npx tsx src/server.ts 2>&1 || true` and check logs show "Socket.IO initialized" (may timeout if DB not running -- that's fine, just check the import/compile works).
  </verify>
  <done>
    Socket.IO server initializes on the existing HTTP server. JWT middleware rejects unauthenticated connections. Authenticated users auto-join program-scoped rooms. Reconnection with lastEventTimestamp retrieves missed events from Redis. emitToProgram utility is exported for Plan 04-02 to wire into mutation services.
  </done>
</task>

</tasks>

<verification>
1. `cd server && npx tsc --noEmit` passes with no errors
2. `socket.io` appears in server/package.json dependencies
3. `server/src/config/socket.ts` exists and exports `initSocketIO`, `emitToProgram`, `getIO`
4. `server/src/shared/socketEvents.ts` exists and exports event types, payload interface, and constants
5. `server/src/server.ts` calls `initSocketIO(server)` in the startup sequence
6. JWT auth middleware rejects connections without a valid token
7. Program rooms are joined based on ProgramMember lookup
8. Redis sorted set stores recent events for catch-up with TTL-based expiry
</verification>

<success_criteria>
- Socket.IO server compiles and initializes alongside Express
- Unauthenticated Socket.IO connections are rejected
- Authenticated users are auto-joined to `program:{programId}` rooms for each of their memberships
- `emitToProgram()` utility is available for mutation broadcasting
- Redis stores recent events per room for reconnection catch-up
- TypeScript strict mode passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-real-time-events/04-01-SUMMARY.md`
</output>
